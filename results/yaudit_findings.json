[
    {
        "title": "1. On-chain contracts assume off-chain trust",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "The 90-day phase 1 period of the Incubator DAO ROOK rage quit process will involve swapping ROOK for pROOK at a 1-to-1 exchange rate. Along with the pROOK token, USDC will also be received at a rate specified by the exchangeRate value. The ROOK token will effectively be pegged to a specific number of USDC tokens during Phase 1. There are some ROOK holders that are excluded from participating in this redemption process according to the governance proposal, but there is no logic in the exchangeROOK.sol contract to prevent these parties from interacting with the contract. This could result in the draining of USDC held in the contract by these excluded parties, which would effectively cause a bank run on the exchangeROOK.sol contract because some ROOK holders will not be able to receive their promised USDC at the set exchange rate. However, it should be noted that the evidence of these acts would be visible on-chain and there is a level of established trust between the ROOK holders which allowed the current governance proposal to be agreed on. Another scenario that would have a negative impact for ROOK holders would involve the Incubator DAO multisig withdrawing ROOK from exchangeROOK.sol using withdrawAssets() to take all the USDC from this contract before other ROOK holders can redeem their tokens. By depositing ROOK into exchangeROOK.sol to get USDC, then using withdrawAssets() to withdraw the ROOK, then depositing ROOK into exchangeROOK.sol ad infinitum, the USDC would get drained from exchangeROOK.sol. This would also effectively cause a bank run on the exchangeROOK.sol contract because some ROOK holders will not be able to receive their promised USDC at the set exchange rate. An alternative approach for the Incubator DAO multisig to gain value is to withdraw ROOK from exchangeROOK.sol using withdrawAssets(), then to swap the ROOK tokens in a liquidity pool before the ROOK token has no value. While the liquidity pool would be imbalanced and be arbitraged due to the set exchangeRate value in exchangeROOK.sol, the multisig could once again take any new ROOK tokens deposited into exchangeROOK.sol and swap it into a liquidity pool again until the exchangeROOK.sol holds no more USDC.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Contract owner can manipulate value received by ROOK or pROOK holders",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "The contract owner will be a 3-of-4 multisig and should generally be a trusted party. However, if this assumption does not hold true, there are several ways the owner could manipulate the value received by ROOK or pROOK token holders: withdrawAssets() could take out all the USDC from the exchangeROOK.sol or exchangepROOK.sol contracts. The mint() function in prook.sol can be called at any time for any amount. The owner could mint many pROOK tokens at the start of Phase 2 and sweep all the USDC from this contract before other token holders get the chance to redeem their pROOK. The setExchangeRate() function could be called to change the ROOK-USDC or pROOK-USDC exchangeRate value in exchangeROOK.sol or exchangepROOK.sol, giving some users more or less USDC in return for their ROOK tokens.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Remove ERC20Votes.sol import",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "Incubator DAO will use the incubdao.eth snapshot.org space for governance voting. Because the governance approach will follow the approach used by ROOK, the same erc20-balance-of snapshot.org voting strategy will be used. This means that there is no need for the pROOK token to include voting logic on-chain, because the token balance held by an address will determine the votes that address receives.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Limit pROOK burn functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "If a user burns their pROOK token, they will lose the chance to redeem their pROOK for USDC during Phase 2 of the Incubator DAO rage quit process. Because ERC20Burnable.sol includes a public burnFrom() function, which only requires an allowance to be given to burn pROOK tokens, it's possible that scam websites could attempt to phish users to sign a pROOK allowance and burn their tokens during Phase 1 so that pROOK holders in Phase 2 would be allocated more USDC. This is because the exchangeRate in Phase 2 will be set to remaining_USDC / pRook.totalSupply(), and burning pROOK would reduce the totalSupply value.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Remove SafeMath import",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "Solidity 0.8.0 introduced a breaking change to implement overflow and underflow protection. This means the SafeMath imports can be removed to save gas on deployment: exchangeROOK.sol import exchangepROOK.sol import",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Declare variables immutable when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "The token variables in exchangeROOK.sol and exchangepROOK.sol can be immutable. They are only set in the constructor and are not changed after that. exchangeROOK.sol token variables exchangepROOK.sol token variables",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Remove ERC20.sol import from exchange contracts",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "The ERC20.sol import in the exchange contracts is not needed and will spend unnecessary gas on deployment, so it can be removed. exchangeROOK.sol ERC20 import exchangepROOK.sol ERC20 import",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use consistent solidity versions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "exchangeROOK.sol and exchangepROOK.sol use solidity 0.8.12, but prook.sol uses solidity ^0.8.9. Because different versions of solidity contain minor differences, and because the newer versions of solidity contain bug fixes and gas optimizations, it is generally recommended to use one of the most recent solidity versions.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Add event to setExchangeRate()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "Consider adding a ExchangeRateSet event in: exchangeRook.setExchangeRate() exchangepRook.setExchangeRate()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Make public functions external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "Declare these public functions as external because they do not need to be called internally: mint() in prook.sol pause() in exchangeROOK.sol and in exchangepROOK.sol unpause() in exchangepROOK.sol and in exchangepROOK.sol",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Incorrect values in governance proposal",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "description": "The governance proposal states that the exchangeROOK.sol exchangeRate will be set by the following equation: an exchange rate defined by Incubator DAO total treasury  (ROOK total supply [1,268,253.79] - DAO owned ROOK [162,807.40] - Strategic Reserve owned ROOK [452,137.53] - DAO contributors owned ROOK [35,175.14]) The first number in this equation is inaccurate and is off by about 5 ROOK. The current on-chain totalSupply value of ROOK token is 1268248.759, which is visible with etherscan or with: cast --from-wei $(cast call 0xfa5047c9c78b8877af97bdcb85db743fd7313d4a \"totalSupply()(uint256)\") The second number in this equation is also inaccurate. Based on the top ROOK holders etherscan chart, the 2nd largest ROOK holder, which we will assume is the DAO owned ROOK tokens, holds 162,780 ROOK. This is a difference of roughly 27 ROOK from the value in the governance proposal. The governance proposal does use the correct value for the Strategic Reserve owner ROOK of 452,137.53. The DAO contributors owned ROOK value is not easily checked at the time of the audit because the tokens are held by different addresses but will be combined into a multisig.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Discrepancy in BaseStrategy versioning",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The git blame of BaseFeeOracle.sol from the yearn-vaults repo shows that the entire file is a new addition for yearn-vaults release v0.4.5. The file diff for PR #546 confirms the introduction of baseFee values in the v0.4.5 release.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. estimatedTotalAssets() does not include value of reward tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The function name estimatedTotalAssets() implies all value held by the strategy is accounted for. The rewards from the staking pool are not, however, included in this calculation. This means after _claimRewards() is called in prepareReturn(), the value of _profit doesn't include the rewards just claimed. The _profit only includes these rewards after ySwap or Cowswap swaps the reward to want, which causes a delay in perceived profits. It may be intentional to only include the value of want and LP tokens in this calculation. Because this is a public function, other users or protocols may assume the function does account for all forms of value held by the strategy, which is an incorrect assumption. Instead, after rewards are claimed by the strategy and are converted into want tokens, the total assets of this strategy will suddenly increase. The amount of this sudden increase could vary depending on how often the rewards are redeemed from the staking pool and how often they are swapped for want. Beyond the inclusion of rewards in the profit and asset values, without guarantees around when the ySwap process will happen, it is possible that the strategy may hold the reward tokens in the form of STG or eTokens for some time. This would delay the start of compound interest on those rewards. Clearer guarantees or incentives to minimize the time between harvest() and the ySwap would resolve this.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Loss calculation discrepancies",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The loss calculation in prepareReturn() is calculated with several assumptions. We will examine each step of the calculations and the relevant assumptions. The first loss calculation is in withdrawSome(). The loss will be zero if _potentialLoss  _totalAssets is true. The problem with this is that a separate finding explains how estimatedTotalAssets() does not include the value of reward tokens, and _totalAssets = estimatedTotalAssets() in this calculation. If there is substantial value stored in reward tokens, the value of _totalAssets would be lower than the value of assets held by the strategy, meaning the loss value may be calculated as a larger loss than in reality once the reward tokens are factored in. The third loss calculation is at the end of prepareReturn(). This calculation compares loss to profit, but like the previous step of loss calculations, profit is dependent on estimatedTotalAssets(), so the profit may be less than in actuality. If _loss > _profit, then the reduction in loss may partially cancel out the inflation of the loss from the previous step, but if _loss",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Variables set to Ethereum addresses",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The strategy is planned to use on other chains, like Optimism. These variables should be defined per chain.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Emergency unstake forgoes extra rewards even when they can be claimed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "_emergencyUnstakeLP is an internal function executed during migration, or during admin-initiated emergency exits. In the former case, migration can be required even if the staker contract is still functional and is receiving rewards. In the latter case, admin can call emergency unstake by mistake when the rewards are still claimable. In both cases, pending rewards will be discarded and irrecoverably stuck in the Stargate LP staker contract.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Duplicate line of code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "In prepareReturn(), the forceHarvestTriggerOnce variable gets set to false. However, the BaseStrategy does the exact same thing right after the call to prepareReturn() is completed, even with the same comment. This line of code (and the comment) is redundant.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Use BaseStrategy logic for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The BaseStrategy saves an if statement in harvestTrigger() by returning the final boolean directly. The current strategy implementation is not as direct.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Require statements are used in the strategy and error messages are not used anywhere. Using this new solidity feature can provide gas savings on revert conditions.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Use simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The prepareReturn() function contains this code: if (_liquidWant  _profit) { _debtPayment = Math.min(_liquidWant - _profit, _debtOutstanding); } else { _profit = _liquidWant; _debtPayment = 0; // enough to pay for all profit and _debtOutstanding (partial or full) }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The first location where unchecked can be applied - _profit = _totalAssets > _vaultDebt ? _totalAssets - _vaultDebt : 0; + unchecked { _profit = _totalAssets > _vaultDebt ? _totalAssets - _vaultDebt : 0; } The second location where unchecked can be applied - (_amountFreed, _loss) = withdrawSome( - _toLiquidate - _wantBalance - ); + unchecked { (_amountFreed, _loss) = withdrawSome( + _toLiquidate - _wantBalance + ); } Similar savings can be found throughout the contract because many logic checks remain from a recent commit where the strategy was migrated from an older version of solidity that did not have built-in SafeMath to a newer version that does have SafeMath. Other examples are found here, here, here, here, here, here, here, here, here, and here.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Remove unneeded variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "_amountFreed is set in prepareReturn() but is never used after that point. The variable and the lines setting it can be deleted to save gas. In withdrawSome(), _liquidatedAmount is used only to return the proper value, and in on branch of the if statement _liquidatedAmount is set to _liquidAssets. Instead of creating a new temporary variable _liquidAssets, use _liquidatedAmount instead and change the if statement logic to - uint256 _liquidAssets = balanceOfWant() - _preWithdrawWant; + _liquidatedAmount = balanceOfWant() - _preWithdrawWant; - if (_amountNeeded > _liquidAssets) { + if (_amountNeeded > _liquidatedAmount) { - _liquidatedAmount = _liquidAssets; uint256 balanceOfLPTokens = _lpToLd(balanceOfAllLPToken()); - uint256 _potentialLoss = _amountNeeded - _liquidAssets; + uint256 _potentialLoss = _amountNeeded - _liquidatedAmount; _loss = _potentialLoss > balanceOfLPTokens ? _potentialLoss - balanceOfLPTokens:0; } else { _liquidatedAmount = _amountNeeded; } At L218 there is no need define _liquidWant and call balanceOfWant(). Recalculate _ wantBalance after L213. Remove variable _liquidWant and use _wantBalance instead.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Remove unneeded if statement",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "withdrawSome() contains an if statement of if (_amountNeeded > 0). The two instances where this internal function is called is on line 210 and line 298. In both instances, the _amountNeeded function argument is greater than zero, so the if statement can be removed because the code in the if statement will always be used.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Unnecessary internal function call",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "_lpToLd() calls liquidityPool.amountLPtoLD(). _lpToLd() is only used once, in withdrawSome(). liquidityPool.amountLPtoLD() is already called directly in valueOfLPTokens(), so _lpToLd() may as well be removed and the single instance of it replaced with a direct call to the external function. The same approach could be taken with _stakeLP() which calls the external lpStaker.deposit() function.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. balanceOfReward() can be external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "If a function is only called externally and does not need to be called internally, it can be declared external for gas savings. Apply this to balanceOfReward().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Faster return from function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "If the input param _amountNeeded is 0 there is no need to do any calculations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Minor fix not applied to mainnet strats",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Changes in recent commits, such as 36ddf75 and a1aaf31, contain changes that do not appear in the mainnet strategy contract code. The code on mainnet is using an older version of the contract code. Although the differences do not appear to impact the logic of the strategy, it is normally a good idea to update code on mainnet when improvements are made.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Incorrect comment(s)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "There is a comment Amount of tokens that all strategies have borrowed in the strategy on the line of code for vault.strategies(address(this)).totalDebt. This comment was copied from the Vault contract's comment about the Vault's totalDebt state variable, and does not properly describe the code on this line because this line uses the totalDebt value in the StrategyParams struct for a specific strategy.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Interfaces are not cleanly defined",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Several unexpected situations are found in the interface files: The standard IERC20 interface file does not have a token() function, but the IERC20Metadata.sol file has a token() function. This is probably a mistake that should be fixed because token() should only be called on pool addresses and is defined in IPool. Instead, consider adding name() to this interface like the OpenZeppelin IERC20Metadata.sol file. The ILPStaking interface contains pendingStargate() and pendingEmissionToken() functions. These functions are not found in the same Stargate contract. The interface combines functions from LPStaking and LPStakingTime to avoid creating a new interface file. decimals() can be removed from IWETH.sol because it is not used in the strategy.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. tradeFactory.disable() never called",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "setTradeFactory() is designed to migrate to a new ySwaps trade factories. _removeTradeFactoryPermissions() removes the approval of the old tradeFactory before a new one is approved. _removeTradeFactoryPermissions() does not call tradeFactory.disable(), but it might be preferable to do so and follow the design of how the TradeFactory contract was written.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Could use Stargate RouterETH for WETH/SGETH conversion",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The list of Stargate contracts deployed on mainnet shows two router contracts, one named Router and one named RouterETH. Strangely, the RouterEth contract does not exist in the main branch of Stargate's github repository. The code is verified on Etherscan and shows that RouterEth.sol integrates with the SGETH contract to support ETH deposits. The addLiquidityETH() function in RouterEth could serve the same purpose as the custom _convertWETHtoSGETH() found in the strategy. Whether it is better to use existing code outside of the strategy or create an implementation in the strategy is up to the developers to determine, and the choice may come down to gas cost.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Documentation improvements possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The only difference between harvestTrigger() in BaseStrategy and Strategy is that the Strategy implementation adds a check for the minReportDelay value and uses > maxReportDelay instead of >= maxReportDelay. Most of the logic in the custom implementation could be replaced by a super.harvestTrigger() as suggested in the BaseStrategy NatSpec.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. No USDT pool on Optimism",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "A comparison was done of the Stargate contracts on the different chains where Yearn Finance operates (mainnet, Arbitrum, and Optimism). The deployed contracts are listed in the Stargate docs. The findings from this comparison were: Mainnet and Arbitrum contracts of Stargate are identical Optimism has no USDT pool There are two differences between Arbitrum and Optimism a) The USDC Pool.sol on Optimism uses a flattened import structure for some odd reason, but otherwise the logic is the same in the pool contract and all imported files b) The LPStaking contract on Arbitrum and mainnet is renamed to LPStakingTime on Optimism and these contract have many differences: i) The LPStakingTime contract on Optimism uses an \"eToken\" with emissions for rewards (not STG). The eToken is OP, the Optimism token. It is a standard OpenZeppelin ERC20 token rather than the custom StarGate token that is not a simple OpenZeppelin ERC20. ii) The LPStakingTime contract on Optimism uses block.timestamp instead of block.number because this is one of the known differences in Optimism. iii) Some functions in LPStakingTime are external while the same function in LPStaking is public.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. == true unnecessary for boolean evaluation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Booleans evaluated with true in the form require(wantIsWETH == true) can be simplified to require(wantIsWETH). The longer form may be easier to understand depending on the reader.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. aeWETH on Arbitrum is not an exact WETH9 clone",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "aeWETH on Arbitrum inherits WETH9 but is not an exact clone of the Ethereum mainnet WETH9 contract like WETH on Optimism. Extra attention may be needed here when deploying the strategy on Arbitrum for WETH.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Rename variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The name _liquidAssets is a bit misleading because it represents only a part of liquid assets, i.e. liquidated assets.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Use vault decimals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Decimals data is stored in the vault. No need to add additional imports.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Use explicit uint type",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Style change.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Unused interface IPriceFeed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Interface is defined but not used in the code.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Missing protected token",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Sweeping LP token, strategy will report a loss. Only unstaken LP tokens can be sweeped. PoC: def test_sweep_lp(gov, vault, strategy, token, user, amount, token_lp, chain, RELATIVE_APPROX): # 1- Deposit to the vault token.approve(vault.address, amount, {\"from\": user}) vault.deposit(amount, {\"from\": user}) assert token.balanceOf(vault.address) == amount strategy.setDoHealthCheck(False, {\"from\": gov}) # 2- Harvest chain.sleep(1) strategy.harvest({\"from\": gov}) assert pytest.approx(strategy.estimatedTotalAssets(), rel=RELATIVE_APPROX) == amount # 3- Unstake LP tokens strategy.unstakeLP(amount, {\"from\": gov}) # 4- Sweep LP tokens unprotected_tokens = [token_lp] for token in unprotected_tokens: strategy.sweep(token, {\"from\": gov}) # Strategy lost all of it's money assert pytest.approx(strategy.estimatedTotalAssets(), rel=RELATIVE_APPROX) == 0 # Strategy still has debt assert vault.strategies(strategy).dict()[\"totalDebt\"] == amount # 5- Report loss chain.sleep(1) tx = strategy.harvest({\"from\": gov}) assert tx.events[\"StrategyReported\"][\"loss\"] == amount assert vault.strategies(strategy).dict()[\"totalLoss\"] == amount",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Change function emergencyUnstakeLP() visibility",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Current visibility is set to public but can be changed to external because strategy uses internal function implementation _emergencyUnstakeLP().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Reward token can be swept by governance",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "BaseStrategy contract has a virtual function to define which tokens cannot be swept by the governance. The Strategy contract does not honor this by not setting the reward token as protected.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Reverts are missing reason string",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "There are five instances of this issue (1, 2, 3, 4, 5).",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Returned address from create is not explicitly checked to be non-zero",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "In assembly, create does not revert when a deployment fails. It instead returns zero address. This is currently not an issue because there is an implicit check due to the call made to the newStrategy. However, not having an explicit check might cause this to be overlooked in future refactorings of the code.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Missing Zero-Address Check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The lpStaker assignment in initializeThis() is missing a zero address check. Granted, there is an implicit revert when a function is called on zero address; however, debugging an unnamed revert could end up consuming valuable time. As such, a zero address check would expedite Strategy deployment and operation by quickly reverting during the construction of the contract if the LPStaker address passed is a zero address.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Cache storage variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Accessing a state variable for the first time in a function takes 2100 gas (Gcoldsload), and then 100 gas (Gwarmaccess) for each additional time. So, it is best to cache (store in a stack/ memory) the storage variable if there are multiple reads for it within the same function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Use calldata for unchanging external function args",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "We can use calldata instead of memory for array, struct or mapping type arguments in external functions, which are not mutated in the function. This will save gas since the argument would not need to be saved into memory first.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Use uint256 for bool values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "On the EVM, changing a state variable from 0 to non-zero uses Gsset and incurs 20,000 gas. In case of bools, every time a bool is changed from false ( value of 0), to true, Gsset cost of 20,000 is incurred.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Unnecessary declaration for Abi Coder pragma",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "Abi Coder v2 is enabled by default since Solidity 0.8.0, hence it is not necessary to explicitly enable it.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Constant is not named in capital letters",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The official Solidity style guide recommends using all capital letters for contants. However, the constant max does not adhere to this guideline.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Anyone can send ETH to the contract via the receive() function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "The receive() function allows the Strategy contract to receive ETH from the WETH contract when the want token is WETH. However, anyone can send ETH to the contract via the receive() function as the address that sends the ETH isn't checked.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Possible precision loss via the _ldToLp function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "description": "In the _ldToLp function the value returned is calculated by first dividing and then multiplying. This could lead to precision loss when liquidityPool.convertRate() != 1. If the convertRate() changes, the _ldToLp function will return lower value than expected.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Dependency on a single DEX for CRV price",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "StrategyConvexFactoryClonable.sol#L430 estimates value of CRV tokens in terms of USDT by routing it through WETH swaps.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Possible revert on creating a vault",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "BalancerGlobal.sol#L368-L375: bytes memory data = abi.encodeWithSignature(\"latestVault(address)\", lptoken); (bool success, ) = address(registry).staticcall(data); if (success) { return registry.latestVault(lptoken); } else { return registry.latestVault(lptoken, VaultType.AUTOMATED); } If no vault is registered for DEFAULT, success is false, and since there is no AUTOMATED type vault, the else clause revert. So in this case, it becomes impossible to create a vault for lptoken.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Strategy migrations fail to claim reward/extraReward tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "There does not appear to be any mechanism to harvest or re-enable a strategy that has been migrated. This means that any unharvested rewards are effectively lost on migration. The magnitude of this finding depends on the amount of time that has passed since the strategy was last harvested. If the strategy has not been harvested in a week & is migrated, then a week's worth of extra rewards are lost. Given the following assumptions/observations, this finding may have a high impact: Some Curve vaults go unharvested for many weeks at a time. CRV/CVX/Extra rewards tend to make up a large fraction of yield revenue. There is no mechanism to prevent a strategy migration when a strategy has not been harvested in a long period of time. If the magnitude/accuracy of the above assumptions are incorrect, then this finding may have medium or lower severity.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. _loss on liquidatePosition() is never accounted in strategy & vault, which can result in funds lost/stuck",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "In BaseStrategy.sol, in harvest() we have this code debtOutstanding = vault.report(profit, loss, debtPayment); which reports the loss to the vault, so if it reports a 0 loss when there is one then the whole accounting logic for the strategy will be incorrect which can lead to loss funds or stuck funds in strategy. Also the correctness of the healthcheck in the strategy will not be certain because of the following code in BaseStrategy.sol that uses loss: require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), \"!healthcheck\");",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Dependence on Curve/Balancer governance",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "Things move quick in this space and \"Curve wars\" bribing adds additional volatility to the situation. With this new automated process for adding pools/strategies, the risk from dependence on external governance processes is amplified. In the event of another governance attack or if a vulnerable token were to enter the system, then malicious actions could be completed more quickly now due to this new permissionless system dependent on approved gauges.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Wrong parameter to cloneStrategyConvex function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "The 3rd parameter in cloneStrategyConvex() is a _rewards address as defined in BalancerGlobal.sol#L83 interface IStrategy { function cloneStrategyConvex( address _vault, address _strategist, address _rewards, address _keeper, uint256 _pid, address _tradeFactory, uint256 _harvestProfitMax, address _booster, address _convexToken ) external returns (address newStrategy); However, the same management address was passed in for both 2nd and 3rd parameters: BalancerGlobal.sol#L479",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Strategy migrations will cause inaccurate accounting on first harvest of new strategy",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "The impact of this finding is dependent on Yearn's strategy management practices & downstream tooling, so consider this impact analysis \"best effort\". If the old strategy has not been harvested in a long time, there may be a relatively large amount of unreported gains/losses that have yet to be realized by the old strategy. This may cause data accuracy problems when analyzing the APR performance for the new strategy. Consider the case where: Old strategy was last harvested a week ago. Old strategy is migrated to new strategy. 10 minutes later, the new strategy is harvested. In the above scenario, a week's worth of gains/losses will be realized by the new strategy, and since the new strategy was deployed 10 minutes prior, off-chain tooling/instrumentation might draw inaccurate conclusions about the performance of the new strategy.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Convex's extraRewards array is unbounded",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "StrategyConvexFactoryClonable#_updateRewards has the following for loop: for (uint256 i; i",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. _loss incorrectly assumed even if rewards can be sold to cover loss",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "In BaseStrategy.sol, in withdraw() the _loss will be returned to the vault. The vault will then report this loss, suggesting the price per share is lower, despite the fact that the strategy could have even been in a profit if rewards were sold.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Setting deposit limit twice",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "BalancerGlobal.sol#L463-L472 v.setDepositLimit(depositLimit) and Vault(vault).setDepositLimit(depositLimit) both set the deposit limit to the same value. The second call is not changing the deposit limit.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. External call on each loop iteration",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "StrategyConvexFactoryClonable.sol#L484 for (uint256 i; i",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Use of SafeMath for safe arithmetic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "StrategyConvexFactoryClonable.sol#L343: _profit = assets.sub(debt); StrategyConvexFactoryClonable.sol#L361: _loss = debt.sub(assets); StrategyConvexFactoryClonable.sol#L565: Math.min(_stakedBal, _amountNeeded.sub(_wantBal)), In all these case, SafeMath can be avoided.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Remove unused state variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "state variable numVaults in BalancerGlobal contract has been set once in createNewVaultsAndStrategies and have never been used any other function. There is an additional SSTORE operation each time we want to create a new vault.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Use >0 for unsigned integers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "!= 0 is a cheaper operation compared to >0, when dealing with uint. >0 can be replaced with != 0 for gas optimization. The >0 has been used in many places in BalancerGlobal and StrategyConvexFactoryClonable contract such as here and here.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Storage variable numVaults in BalancerGlobal is not needed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "The variable is set only once in numVaults = deployedVaults.length;. There is no need to use a separate storage slot for this value, you can just add a getter method for deployedVaults.length instead Recommendation Add a getter method for deployedVaults.length and remove numVaults storage variable. Developer Response Great. Fix has been taken. 7. Gas - recalculation not needed (datapunk) Proof of concept As marked in the the snippet below, there is no need to recalculate _profit.add(_debtPayment) and _profit In L#345 uint256 toFree = _profit.add(_debtPayment); //freed is math.min(wantBalance, toFree) (uint256 freed, ) = liquidatePosition(toFree); if (_profit.add(_debtPayment) > freed) { // *** if (_debtPayment > freed) { _debtPayment = freed; _profit = 0; } else { _profit = freed - _debtPayment; // *** remove } } Recommendation use toFree in place of _profit.add(_debtPayment) and remove else { ... } 8. Gas - remove tradesEnabled (datapunk) Proof of concept tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. recalculation not needed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "As marked in the the snippet below, there is no need to recalculate _profit.add(_debtPayment) and _profit In L#345 uint256 toFree = _profit.add(_debtPayment); //freed is math.min(wantBalance, toFree) (uint256 freed, ) = liquidatePosition(toFree); if (_profit.add(_debtPayment) > freed) { // *** if (_debtPayment > freed) { _debtPayment = freed; _profit = 0; } else { _profit = freed - _debtPayment; // *** remove } } Recommendation use toFree in place of _profit.add(_debtPayment) and remove else { ... } 8. Gas - remove tradesEnabled (datapunk) Proof of concept tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. remove tradesEnabled",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Redundant external call when using staticcall",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Upgrade Pragma",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Missing events in BalancerGlobal & StrategyConvexFactoryClonable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "StrategyConvexFactoryClonable has several occurrences of the safeApprove method calls. This method has been deprecated by OpenZeppelin and its usage is discouraged.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. ERC20.safeApprove is deprecated",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "StrategyConvexFactoryClonable has several occurrences of the safeApprove method calls. This method has been deprecated by OpenZeppelin and its usage is discouraged.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. incorrect comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "L505 comment on turnOffRewards() says it will set the allowance on the router to 0. This doesnt happen in turnOffRewards",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. hardcoded addresses",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "Hard coded addresses in multiple places: StrategyConvexFactoryClonable.sol and BalancerGlobal.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. VaultRegistry.latestVault() functions can consume all gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "description": "Vault registry is a proxy and 0xc3efbfdb50cf06e8e5bb623af28678d72caeafea is its current implementation. It has 2 latestVault() functions: function latestVault(address _token) external view returns (address) { address[] memory tokenVaults = vaults[_token][VaultType.DEFAULT]; // dev: no vault for token return tokenVaults[tokenVaults.length - 1]; // dev: no vault for token } function latestVault(address _token, VaultType _type) external view returns (address) { address[] memory tokenVaults = vaults[_token][_type]; return tokenVaults[tokenVaults.length - 1]; // dev: no vault for token } Both the functions copy the storage array in memory.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. No function to freeze transfers after unfreezing them",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol#L16, YFUtechne.sol#L33-L35",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Fix supportsInterface()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol#L65-L72",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. NFT minting might be unfair if demand is high",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol#L41-L50",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Add sweep functions for Ether and ERC20 tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Use call to transfer Ether",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol#L45: The mint fee is transferred to depositAddress as follows: depositAddress.transfer(PRICE);",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Use constant and internal variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol#L13-L14",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Mark public functions as external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol#L25-L50",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use OpenZeppelin's Ownable instead of AccessControl",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol#L5",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Don't transfer mint fee to depositAddress on each mint",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol#L45",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use uint256 for _tokenIdCounter",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol#L11, YFUtechne.sol#L47-L49",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Explore solmate's ERC721 and ERC1155 implementation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "solmate's ERC721.sol, solmate's ERC1155.sol",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Make sure to add / at the end of IPFS base URI",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "OpenZeppelin's ERC721.sol#L97",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. _beforeTokenTransfer() should be marked as view",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol#L52",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Add unit tests to gain confidence",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Follow Solidity style guide",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "description": "YFUtechne.sol",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Incompatible Vote Delegation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The VoteDelegation.sol contract has functions including delegate() and removeDelegation(), but the VoteDelegation.sol contract does not have any interaction with the snapshot DelegateRegistry contract. Because there are no contract calls to snapshot.org contracts, snapshot.org will not register any vote delegation.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Lock 1e-18 YFI to Get Rewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "def test_gauge_cheat_yfi_lock( yfi, ve_yfi, whale, whale_amount, shark, shark_amount, fish, fish_amount, create_vault, create_gauge, gov ): yfi.approve(ve_yfi, shark_amount, {\"from\": shark}) ve_yfi.create_lock( shark_amount, chain.time() + 4 * 3600 * 24 * 365, {\"from\": shark} ) assert yfi.balanceOf(shark) == 0 yfi.approve(ve_yfi, fish_amount, {\"from\": fish}) ve_yfi.create_lock( fish_amount, chain.time() + 4 * 3600 * 24 * 365, {\"from\": fish} ) assert yfi.balanceOf(fish) == 0 yfi.approve(ve_yfi, 1, {\"from\": whale}) ve_yfi.create_lock( 1, chain.time() + 4 * 3600 * 24 * 365, {\"from\": whale} ) assert yfi.balanceOf(whale) == whale_amount - 1 lp_amount = 10**18 vault = create_vault() tx = create_gauge(vault) gauge = Gauge.at(tx.events[\"GaugeCreated\"][\"gauge\"]) vault.mint(shark, lp_amount/100) vault.approve(gauge, lp_amount, {\"from\": shark}) gauge.deposit({\"from\": shark}) vault.mint(fish, lp_amount/100) vault.approve(gauge, lp_amount, {\"from\": fish}) gauge.deposit({\"from\": fish}) vault.mint(whale, 100*lp_amount) vault.approve(gauge, 100*lp_amount, {\"from\": whale}) gauge.deposit({\"from\": whale}) yfi_to_distribute = 10**16 yfi.mint(gov, yfi_to_distribute) yfi.approve(gauge, yfi_to_distribute, {\"from\": gov}) gauge.queueNewRewards(yfi_to_distribute, {\"from\": gov}) assert pytest.approx(gauge.rewardRate()) == yfi_to_distribute / (7 * 24 * 3600) chain.sleep(3600*24*7) chain.mine() assert gauge.earned(whale)",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Flash Loan Sybil Attack to Boost Rewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "Boosted Balance equation: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L302 Deposit Update Reward call: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L351 Total Supply increase: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L362",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Incorrect variables in getRewardFor call",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The _account variable should be used in this line instead of msg.sender https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L512 IExtraReward(extraRewards[i]).getRewardFor(msg.sender); The _account variable should be used in this line instead of msg.sender https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L501 IVotingEscrow(veToken).deposit_for(msg.sender, reward);",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Unclear Integration of Vote Delegation Until Value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The VoteDelegation.sol contract has functions including delegate() and removeDelegation(), but the VoteDelegation.sol contract does not have any interaction with the snapshot DelegateRegistry contract. Because the actual act of voting is planned to happen off-chain with snapshot.org, snapshot.org needs to recognize what a valid vote or delegation is in the snapshot that it takes for each proposal. Currently there is no option in the snapshot.org delegation approach for an \"until\" value. Factoring in the \"until\" value could be implemented in a custom snapshot.org voting strategy, but because no such strategy is mentioned anywhere in the veYFI repository, it is expected that this has not been considered.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. force_withdraw() penalty may inadequately deter gamification and attacks on voting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The penalty_ratio equation https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L570",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Voting delegation is missing edge case checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The VoteDelegation.sol contract permits an until variable value of zero if the tokens are not locked. Any until variable value that is less than block.timestamp should have no impact on voting or delegation. But if the until value starts at zero, it is possible for the value to be increased to a value less than block.timestamp to reference a time in the recent past, but still have no impact. It is possible that the voting logic, which is not within the scope of these solidity contracts, may not properly consider this edge case. This edge case can be solved by adding a check in all functions that modify the until state variable, including _delegate() and increaseDelegationDuration(), to validate require(until > block.timestamp). An exception could be made for an until value of zero, resulting in a require statement that looks like require(_until > block.timestamp || _until == 0). Another edge case is a situation where the until value is set to a time beyond the lock expiration of the veYFI tokens. There is no check for to confirm until",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Sawtooth Wave Effect from Computing veYFI Balance and Supply Using Different Time Scales",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "Equation to compute Total Supply: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L756 (t_i is truncated to a value in weeks at L748 and L750.) Equation to compute Balance: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L677 _t is set to block.timestamp for balance computation: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L647",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Equal penalty reward distribution not incentive aligned",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "A discussion for this issue was started by someone from Ribbon Finance (who forked the veYFI code) before the review ended in veYFI Issue 135 and a fix is being developed in PR #136. The issue is centered around how penalty fees paid in VotingEscrow.vy and Gauge.sol are redistributed to users.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. No penalty during migration",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The _lockingRatio() function returns PRECISON_FACTOR, equivalent to locking for the MAX_TIME value, when the ve token is undergoing migration: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L221 Instead, it would be better to revert in this case so that the ve token can be finished without any users taking advantage of this edge case.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Using \"unchecked\"",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The _lockingRatio() function returns PRECISON_FACTOR, equivalent to locking for the MAX_TIME value, when the ve token is undergoing migration: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L221 Instead, it would be better to revert in this case so that the ve token can be finished without any users taking advantage of this edge case.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Using simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The _notifyRewardAmount() function in BaseGauge.sol contains https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L170-L177 if (block.timestamp >= periodFinish) { rewardRate = reward / duration; } else { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rewardRate; reward = reward + leftover; rewardRate = reward / duration; } By switching around the if/else clauses, we can replace the compound operator with a simple one if (block.timestamp",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Use prefix in loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "There are 4 instances of this in Gauge.sol and 1 instance in VoteDelegation.sol https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L161 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L357 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L386 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L511 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VoteDelegation.sol#L121",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Payable functions can save gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The following functions have the onlyOwner modifier and can be marked as payable setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L49 addVaultToRewards() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L67 removeVaultFromRewards() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L94 setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L30 setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L110 setDuration() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L73 sweep() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L111",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Use != 0 for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Declare functions external for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "There are two public functions that can be external https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L287 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L317",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Remove Aragon calls for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The following functions include comments indicating they are fulling or partially used for Aragon compatibility, and may not otherwise be necessary: version state variable and _version init parameter https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L155 controller() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L129-L131 transfersEnabled() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L129-L131 balanceOf() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L650 totalSupply() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L772 changeController() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L831-L837",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Inconsistent zero case in VotingEscrow.vy",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The balanceOf() function uses this code: if upoint.bias = 0: return convert(upoint.bias, uint256) else: return 0",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Remove duplicated code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The logic for the case block.timestamp >= periodFinish and (distributedSoFar * 12) / 10 = periodFinish || (distributedSoFar * 12) / 10",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. SLOAD gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "Existing code https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L80-L84 Modified code to use local variable instead of state variable in emit if (block.timestamp",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. SafeERC20 functions not used",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "Gauge.sol line 500 => rewardToken.approve(address(veToken), reward); Gauge.sol line 527 => IERC20(rewardToken).approve(veYfiRewardPool, toTransfer); VeYfiRewards.sol line 140 => rewardToken.approve(address(veToken), reward);",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Unspecified Voting Requirements",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "There are built-in voting assumptions in the contract code, mostly borrowed from Convex: When a proposal is created, the checkpoint() function in VotingEscrow.vy should be called to properly set the epoch Voting power should be calculated using the on-chain functions such as get_last_user_slope(), balanceOf(), balanceOfAt(), supplyAt(), totalSupply(), and totalSupplyAt() in VotingEscrow.vy. Note that some of the math in these calculations could be moved to an off-chain voting strategy for gas savings Voting for a proposal with veYFI is allowed as soon as the veYFI is locked. Because there is potential for gamification in increasing veYFI stake shortly before key votes, protocols like Convex have implemented a minimum locking duration of several weeks before a token holder can vote, which is implemented in their VotingEligibility.sol contract. Some open and unanswered questions include: Who is allowed to create proposals on snapshot.org? How are the results of each snapshot vote converted to on-chain rewards? Is this automated? Will all vaults receive a gauge that can be voted for on snapshot.org, even those holding very little value? If so, this could lead to gamification of deprecated or old vaults. Is there a maximum allocation a gauge can receive? Is there minimum quorum for governance votes? Convex specifies these values: https://docs.convexfinance.com/convexfinance/general-information/voting-and-gauge-weights",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Variable naming inconsistency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The first input to initialize() has the following comment https://github.com/yearn/veYFI/blob/d53465c5f615a04204faed55728840a1e79377fc/contracts/Gauge.sol#L67 _stakingToken The vault token to stake Elsewhere in veYFI, the naming convention assumes that each gauge corresponds to one Yearn vault. But the name _stakingToken and the comment in issue 46 indicates this might not be correct. This should be clarified in the comments and the variable names.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Missing 0 check in setDuration()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "If block.timestamp  periodFinish https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L73 This can cause problems in other functions that divide by the duration https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L170-L177",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The MAX_DELAGATED variable should be spelled MAX_DELEGATED https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VoteDelegation.sol#L16 betwwen should be between https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L324 The last sentence in the ExtraReward.sol contract needs to be fixed, most likely by removing the words \"Gauge will\". It reads \"Gauge will this contract is used behind multiple delegate proxies.\" https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L13-L14 \"claimm veYFI and aditional reward\" should be \"claim veYFI and additional reward\" (two typos) https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L373 Triger should be Trigger https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L131 veYFITotalSypply should be veYFITotalSupply https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L284 \"rewards are distributed during 7 days\" should says \"rewards are distributed during reward duration\" because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L12 \"over a week\" should say \"over the reward duration\" because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L130 \"restart a new week\" should say \"restart a new reward duration\" because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L154 A reference to CRV exists in the vyper code. Change ERC20CRV to ERC20YFI https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L152 \"earning for an account\" should be \"earnings for an account\" https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L248-L249 \"address acccount\" should be \"address account\" https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L219",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The value 1e18 appears throughout the contracts https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L62 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L69 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L245 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L274 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L280 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L75 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L86 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L92",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Code inconsistency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The three different _updateReward() functions https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L44 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L36 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L183",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Curve safety check removed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "This is the check in Curve: https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455 The check does not exist in the same locations in the veYFI VotingEscrow contract: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L458 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L496 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L512 If this check is added to veYFI, it should also be added to createLockFor, a function that Curve does not have: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L477",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. No migrateLock sample implementation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The migrateLock() call in the existing veYFI code: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L606",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Use -= to keep code concise",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The += operator is used often in veYFI, but the -= operator is not used in this line https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L391 _balances[msg.sender] = _balances[msg.sender] - _amount; Consider changing this line to _balances[msg.sender] -= _amount;",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Update rewards for other users",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "description": "The depositFor() function: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L344",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Add token revocation to functions granting approval",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md",
        "description": "Currently only enterWithUnderlying() and enterWithVaultShares() revoke token approval after the function has finished executing.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. nonReentrant isn't needed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md",
        "description": "nonReentrant is usually needed when a function is manipulating state variables that are used in other functions. In this case, the functions listed below are not manipulating state variables that are used in other functions, so the nonReentrant modifier is not needed. List of functions: zapIn in BunniLpZapIn.sol line 79 zapInNoStake in BunniLpZapIn.sol line 155 enterWithUnderlying in BunniLpZapIn.sol line 221 enterWithVaultShares in BunniLpZapIn.sol line 255 doZeroExSwap in BunniLpZapIn.sol line 309",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Payable functions don't receive ETH",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md",
        "description": "The following functions are marked as payable but are not used as such: doZeroExSwap in BunniLpZapIn.sol line 309 selfPermit in SelfPermit.sol line 36 selfPermitIfNecessary in SelfPermit.sol line 40 selfPermitAllowed in SelfPermit.sol line 47 selfPermitAllowedIfNecessary in SelfPermit.sol line 54",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Add events to functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md",
        "description": "While the underlying dependencies in each function of the BunniLpZapIn contract emit events, the functions themselves do not emit events.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Callback customization allows arbitrary contract execution",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Missing logical protections in setIntervals()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. BCV decrease design does not give market owner optimal price",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. totalDebt value overwritten",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Values grow quickly near end of market",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Inaccurate assumption about scaleAdjustment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Anyone can trigger a market closure",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Missing zero case checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Incompatible with fee-on-transfer tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use != 0 for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Unnecessary zero initialization",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Use prefix in loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "There are several instances of this finding: https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L177 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L180 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L186 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L191 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/OlympusTreasuryCallback.sol#L74",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Cache array length before loop",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Bitshift is cheaper for powers of two",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Remove unused functions from imported libraries",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Remove unused variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Cache variable for reuse",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Tidy up _handlePayout logic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Redundant return variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Use unchecked when no risk of overflow or underflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Move variable assignment to avoid overwrite",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Using simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Bond purchase size does not impact price",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Frontrunning changes price",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Unclear if default tuning parameters are optimal",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Add a check to limit debtBuffer to 100%",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Function format inconsistency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Variable name nitpick",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. TransferHelper.sol not from solmate",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. CloneERC20.sol missing EIP-2612 code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Incorrect comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Confusing variable naming",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Expired markets are never \"closed\"",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Legitimate tokens disallowed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Tokens with non-string metadata disallowed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. vesting and expiry sometimes used interchangeably",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. market price functions consistency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Use variable instead of magic numbers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "description": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Incorrect order of operations in LibCompound.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The problematic computations are for the variables interestAccumulated and the return value. interestAccumulated calculation from transmissions11/libcompound repo: uint256 interestAccumulated = (borrowRateMantissa * (block.number - accrualBlockNumberPrior)).mulWadDown( borrowsPrior ); interestAccumulated calculation from local LibCompound.sol contract: uint256 interestAccumulated = borrowRateMantissa * block.number - accrualBlockNumberPrior.mulWadDown(borrowsPrior); Made up example values: borrowRateMantissa = 1000000000 block.number = 15460000 accrualBlockNumberPrior = 15459990 borrowsPrior = 500000000000000000000000 interestAccumulated result from transmissions11/libcompound: 5000000000000000 interestAccumulated result from local LibCompound.sol: 15452270005000000 Return value calculation from transmissions11/libcompound repo: (totalCash + totalBorrows - totalReserves).divWadDown(totalSupply); Return value calculation from local LibCompound.sol contract: totalCash + totalBorrows - totalReserves.divWadDown(totalSupply); Example values loosely taken from cDAI: totalCash = 400000000000000000000000000 totalBorrows = 300000000000000000000000000 totalReserves = 20000000000000000000000000 totalSupply = 3100000000000000000 Return value result from transmissions11/libcompound: 219354838709677419354838709 Return value result from local LibCompound.sol: 693548387096774193548387097",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. User can set arbitrary approveMaxIfNeeded() target",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "This finding is not a complete attack chain, but the missing link of the chain depends on a hypothetical weakness in an external contract, which is out of scope of this review. In order for value to be stolen from Swapper.sol, a malicious actor would: Create a malicious contract that is approved by Swapper.sol for ERC20 tokens that pass through Swapper.sol, which enables it to transferFrom() those tokens Use an external call from Swapper.sol to call the malicious contract while Swapper.sol holds value to take that value before it can be sent to the user calling the contract The first step is possible because the input argument to approveMaxIfNeeded() in Swapper.sol code is a user-specified argument. Not only that, but in a function such as _swapXpytToUnderlying(), the args.gate parameter approved for args.xPYT here is only used for one function call, exitToUnderlying(). This function could be implemented in a malicious contract as an empty function and the rest of the _swapXpytToUnderlying() function would still succeed, allowing the args.gate user-specific argument to be set to an address under the malicious user's control. Even worse, this exitToUnderlying() could be where the transferFrom() call happens, so if an innocent user specifies this value for the args.gate value (either due to a mistake, a Timeless frontend hack, or any other means), the value would be transferred to the malicious gate contract and the innocent user would lose the value that was going to be sent to them. It is not even necessary for the user to provide a malicious value for args.gate for this to become a problem. Multiple external calls exist within the functions of Swapper.sol, and if any of these are insecure or have an external call to an insecure contract, loss of value can occur even if the user's transaction has the proper function argument values set.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Lack of slippage protection in Curve swaps",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The exchange() call in _swap() in CurveV2xPYT.sol sets a minimum output token quantity of zero. This means the swap will happen regardless of how imbalanced the pool is. The only check that is applied to the quantity of tokens received is validating the amount is greater than minXpytAmountOut. The value of minXpytAmountOut does not help with slippage and is not user customizable, it only helps avoid a case where a very small (near zero) amount of of xPYT is returned. This is in contrast to where pool.exchange() is used in _swapFromUnderlying() in the swapper repository. There is a check of tokenAmountOut",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Accrued rewards may not be returned to depositors",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The claimRewards() function is an external function without access controls, so anyone can call it. When it is called, the liquidity mining incentive rewards accrued to the aTokens held by the ERC4626 vault are sent to the address rewardRecipient. The rewardRecipient address may be a previously audited contract that is out of scope of this review, but because it is not in the scope of this review, it is not clear whether users will receive rewards claimed from this function.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Bypass to add cEtherAddress to underlyingToCToken array",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The CompoundERC4626Factory.sol constructor has an if statement that prevents cEtherAddress from getting added to the underlyingToCToken array. The updateUnderlyingToCToken() function has a for loop very similar to the constructor, but the if statement check is missing. Because updateUnderlyingToCToken() has no access controls, anyone can use updateUnderlyingToCToken() to add the cEtherAddress to the array. This will cause problems because the CompoundERC4626.sol code assumes ERC20 tokens when using imported SafeTransferLib functions and does not use safeTransferETH() for the case where ETH is the underlying asset.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Improper wrapEthInput() call can cause value loss",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "If a user calls wrapEthInput() as a separate transaction, ether will be converted to WETH and deposited to the Swapper.sol address. Even if the user intends to call swapUnderlyingToXpyt() or swapUnderlyingToNyt() in their next transaction, the user can be frontrun. Whoever calls swapUnderlyingToXpyt() or swapUnderlyingToNyt() while Swapper.sol holds value can extract that value because those functions use args.underlying.balanceOf(address(this)) for the value of tokenAmountIn (here and here).",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. ERC20 tokens sitting in contracts can be extracted",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The Swapper.sol contract uses the code args.TOKEN.balanceOf(address(this)) in several places. The value of args.xPYT, args.pyt, or args.nyt can be any address, which means any token balance stored by the contract can be queried, and soon after extracted, with this code. The contract is not designed to store value, but if it does store value (say if a user accidentally sends tokens directly to the contract), the value could be extracted in a backrun transaction. A similar scenario exists with Uniswap's V2 router, which is not designed to store any token balances but it does have non-zero token balances as seen on etherscan. Separately, sweep() in xPYT.sol is described with Uses the extra asset balance of the xPYT contract to mint shares. This can remove any extra assets of token asset that sits in the xPYT.sol contract. While less generalize than the Sweeper.sol contract, a more specific case of the same issue exists.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Difficult to use withdraw() with full deposit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "Aave allows users to submit the value type(uint256).max to withdraw the user's full balance. No similar feature is present in the Yield Daddy ERC4626 vault. This makes it hard to use withdraw() while specifying the correct value of assets to remove all aTokens from the vault because the aTokens are rebasing and increasing over time. In contrast, the redeem() function allows a user a specify the number of shares they want to withdraw. Shares are not always rebasing and are easier for a user to specify an accurate number for a complete withdrawal.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Inaccurate function return values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The maxDeposit() and maxMint() functions only return the value type(uint256).max when the underlying pool can accept a deposit or mint. The value type(uint256).max does not accurately represent the maximum value that can be deposited into the vault when some ERC4626 tokens have already been minted. This is because the vault normally can mint a maximum of type(uint256).max, otherwise the totalSupply state variable will overflow and cause a revert, so the existing token supply should be subtracted. The same is true for aTokens, which should have the existing supply excluded. EIP4626 defines this requirement for maxMint(): MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). The output of maxDeposit() cannot be passed into withdraw() without a revert, which does not satisfy this ERC4626 requirement. A more accurate return value for maxDeposit() in Aave V2 and Aave V3 is: return type(uint256).max - aToken.totalSupply(); The totalSupply value limitation of the ERC4626 vault can be ignored because the totalSupply of the vault will always be less than or equal to aToken.totalSupply(), so the aToken totalSupply is the limiting factor. The same issue is relevant for maxMint(), but the return value of maxMint() should be in units of shares instead of assets because the ERC4626 mint() function takes a shares value as input. The more accurate return value for maxMint() in Aave V2 and Aave V3 is therefore: return convertToShares(type(uint256).max - aToken.totalSupply()); This issue is present in the Compound ERC4626 wrapper as well. A similar solution should be applied.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. No fee-on-transfer token support",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "Fee-on-transfer tokens have the property where the value that is sent is not the same as the value that is received. This difference in logic compared to standard ERC20 tokens requires special handling in solidity to avoid a revert or loss of value. No fee-on-transfer ERC20 appears to exist on the supported lending platforms at the time of the review, but if one is added in the future or if the fee is enabled on an existing token that supports fee-on-transfer, the ERC4626 wrappers for protocols that require two separate transfers for depositing and withdrawing (Euler, Compound, Aave only for depositing) would not function with fee-on-transfer tokens because the deposit or withdraw process would revert because the fee is not accounted for in between the two transfers. The swapper repo also lacks fee-on-transfer support. This is because the tokenAmountIn value used in the safeTransferFrom() call is assumed to equal the value held by the Swapper.sol contract after the transfer takes place. This will revert when args.gate.enterWithUnderlying() is called because the underlying.safeTransferFrom() call in Gate.sol's enterWithUnderlying() will not have sufficient balance to transfer.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Curve's price_oracle() may provide less effective sandwiching protection post-merge",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "In the upcoming Merge of the Ethereum mainnet, block proposers and validators are assigned randomly 2 epochs in advance. This enables an attacker with a sufficient amount of capital to fully manipulate the contents of two or more blocks in a row, undermining previous the security assumption that arbitrageurs could disrupt a multi-block oracle manipulation attack. This risk is compounded by price oracles that put more weight on recent observations, such as Curve's EMA oracle.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Insufficient SwapArgs input validation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "There is no validation in _swapUnderlyingToNyt() that confirms that the addresses of args.underlying, args.nyt, args.pyt, args.xPYT, and args.vault are all related to the same underlying asset. Similarly, the value args.gate may not hold the address of the actual Gate.sol contract in the timeless protocol, but instead may be the address of an attacker's contract. An external call is made to args.gate in _swapUnderlyingToNyt() and _swapUnderlyingToXpyt(), and although the external functions swapUnderlyingToNyt() and swapUnderlyingToXpyt() have the nonReentrant modifier, there is no global reentrancy lock across the Timeless protocol(s), so the risk of a hack involving reentrancy is not zero.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Curve Swap design may generate unexpected NYT/PYT dust",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "According to the documentation, CurveV2Swapper's swapNytToUnderlying() and swapXpytToUnderlying() functions are intended to be used in conjunction with CurveV2Juggler.juggleXpytInput() and CurveV2Juggler.juggleNytInput() respectively. These two juggle function are intended to operate as off-chain oracles which are used to calculate the correct quantities of NYT/PYT tokens to be swapped. The goal of the swap is for the user to end up with a nominally equivalent number of NYT+PYT tokens for a vault, which are then redeemed in equal amounts for xPYT tokens, which is then redeemed for the underlying vault's token. The decoupling of the off-chain price oracle with the on-chain swap introduces a chance that the swap is executed at a different price that the price oracle expected. If a swap is executed at a different price than the oracle predicted, then the user will have differing quantities of NYT and PYT, and will have some amount of dust remaining after they redeem their NYT+PYT for xPYT.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. xPYT deployment lacks trust mechanism",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "Often the CREATE2 opcode is used to deploy contracts that depend on underlying parameters, because the address of the contract can be derived from those underlying parameters. This is the approach used in deployYieldTokenPair() of Factory.sol to deploy new NYT/PYT pairs and by Uniswap V2 to deploy new pairs. But because multiple xPYT tokens can exist for a single underlying vault, perhaps CREATE2 cannot be used in this case. There is no state variable in CurveV2xPYTFactory.sol that stores the address of deployed xPYT contracts, which means that functions that accept a xPYT address as a function argument, including several functions in Swapper.sol that have a SwapArgs.xPYT function argument, cannot determine whether the xPYT address is a legitimate xPYT token or a malicious contract. This is unlikely to impact most users who use a web interface in their browser, but it may open up an attack vector of a malicious contract posing as a legitimate xPYT token.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Missing PYT/NYT lookup mechanism",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The PerpetualYieldToken.sol and NegativeYieldToken.sol contracts contain many external calls to the gate contract, notably the gate.beforePerpetualYieldTokenTransfer() call in PYT's transfer() and transferFrom() functions and the gate-protected gateMint() and gateBurn() in BaseERC20.sol. If the gate is malicious, it could leverage these callbacks for a variety of attack vectors.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Replace require blocks with errors",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "Instances of require that can be replace with custom errors are found in: AaveV2 AaveV3 xPYT",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Declare variables internal, immutable, or constant when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "Many public immutable variables exist in the Euler, Aave V2, Aave V3, and Compound wrappers. If possible, make these internal instead of public for gas savings. There is one variable in xPYT.sol, assetBalance, that can be made private because it already has a public getter function in the form of totalAssets(). A variable in CurveV2xPYT.sol, curvePool, can be made immutable because it is only changed once, in the initializer.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Remove beforeWithdraw() calls",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "withdraw() and redeem() call beforeWithdraw(), but beforeWithdraw() is never implemented with code. beforeWithdraw() is declared in ERC4626.sol as an empty virtual function. The calls to beforeWithdraw() can be removed because it doesn't run any code.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Replace duplicate code with internal function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The code below is found in two places in AaveV2ERC4626.sol (here and here): // check if pool is paused if (lendingPool.paused()) { return 0; } // check if asset is paused uint256 configData = lendingPool.getReserveData(address(asset)).configuration.data; if (!_getActive(configData)) { return 0; } This code could be moved into an internal view function to reduce contract deployment costs. The same could be done with the similar duplicate code block (here and here). The Aave V3 wrapper has duplicate code in the same functions of maxDeposit(), maxMint(), maxWithdraw(), and maxRedeem().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Declare functions external for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "There is a public function updateUnderlyingToCToken() in CompoundERC4626Factory.sol that can be made external.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Use claimComp() with borrowers = false",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "claimComp() is called in claimRewards(). It can be replaced with a call to the other claimComp() function with borrowers set to false.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "There are two subtraction operations (here and here) that should not underflow because the supplyCap should be greater than the value of totalSupply(). The Aave V3 code should be checked to confirm that there is a valid comparison to supplyCap when the supply increases. Another subtraction operation can be made unchecked in CurveV2Juggler.sol (and the out of scope UniswapV3Juggler.sol contract), found here and here. This operation can be unchecked because tokenAmountIn >= (tokenAmountIn >> 1), and because swapAmountIn = (tokenAmountIn >> 1), then tokenAmountIn >= swapAmountIn and tokenAmountIn - swapAmountIn >= 0. Swapper.sol has two operations repeated four times that can be unchecked to save gas. A similar operation that already is unchecked is found in xPYT.sol. Division here, here, here, and here can be unchecked because (protocolFeeInfo_.fee / 10000)",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Function arg should be calldata not memory",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The Compound factory contract has a memory argument that can be changed to calldata for gas savings. The same change can be made for _deployCurvePool() in CurveV2xPYTFactory.sol.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Move revert earlier in function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "This revert check in the xPYT constructor can take place earlier in the constructor because it only relies on a function argument and does not rely on any other calculations. Move this if statement to immediately follow the other if statement revert check.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Internal function is cheaper than modifier",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "This onlyOwner modifier could be replaced with a require check in this function or an internal function. For example, add this line to ownerSetProtocolFee() to replace the modifier on the function. require(msg.sender == owner, \"UNAUTHORIZED\");",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Zero check could save gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "getClaimableYieldAmount() is called once in xPYT.sol, but this function is missing a zero check for yieldAmount. The first function that calculates the claimable yield, claimYieldAndEnter(), confirms that yieldAmount != 0. The other locations where the claimable yield is calculated, getClaimableYieldAmount, does not confirm that yieldAmount != 0. This zero check could provide a gas savings in the case that yieldAmount is zero.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Remove unnecessary approve",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "This approve() call is designed to initialize the storage slot to a non-zero value in order to save gas on future changes of this slot. The problem is that the approve() call that happens before each swap overwrites the initial allowance value, which is subsequently consumed by the Curve swap and re-set to zero.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Unnecessary logic in approveMaxIfNeeded() function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The contracts that call approveMaxIfNeeded() include Swapper.sol and CurveV2Swapper.sol. No other approve() or safeApprove() calls happen in these contracts, so the only allowance being set is an allowance of type(uint256).max. If the allowance is set to type(int256).max, USDT will not decrease the allowance when a transfer happens. So the process of checking the allowance and setting it to zero if the value is not type(int256).max is unnecessary and can be replaced with a simple token.safeApprove(spender, type(uint256).max); call. There might be an edge case other than USDT that the approveMaxIfNeeded() was designed for, but the function should not be necessary for USDT or standard ERC20 tokens.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Direct transfer of aTokens impacts share value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "function totalAssets() public view virtual override returns (uint256) { // aTokens use rebasing to accrue interest, so the total assets is just the aToken balance return aToken.balanceOf(address(this)); } The totalAssets() function in AaveV2ERC4626.sol and AaveV3ERC4626.sol is an important function. It is called in the calculations of convertToShares(), convertToAssets(), previewMint(), and previewWithdraw(). It is possible for anyone to transfer Aave aTokens directly to the vault, which would change the value returned by totalAssets(). Although such an increase in value happens normally as deposits take place or yield is earned, an instantaneous change may impact how other protocols interface with Yield Daddy ERC4626 tokens depending on how the other protocols are implemented. This comment is absent from the Compound ERC4626 wrapper, but the same edge case of a user sending tokens directly to the vault can apply.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. aAMPL edge cases",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "AMPL is a rebasing token, but unlike Aave aTokens, AMPL can increase or decrease the balance that user's hold. This website shows some recent rebasing activity in both the positive and negative directions. The ability to rebalance in either direction means that a user depositing into the Yield Daddy aAMPL vault may receive less tokens when withdrawing than when they deposited. If there are very few depositors in the aAMPL vault, a user with a large fraction of vault ownership may be able to take advantage of the timing of the AMPL rebasing (which happens once per day) at the cost of the other vault shareholders.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Invert constant mask variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "Modify the constant masks in the Aave V3 wrapper to the following: - uint256 internal constant DECIMALS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; + uint256 internal constant DECIMALS_MASK = 0xFF",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Simplify logic in maxDeposit() and maxMint()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "maxDeposit() and maxMint() have logic which can be simplified: - if (!(_getActive(configData) && !_getFrozen(configData) && !_getPaused(configData))) { + if (!_getActive(configData) || _getFrozen(configData) || _getPaused(configData)) {",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Add parentheses to avoid order of operations ambiguity",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "These three functions have boolean logic that relies on order of operations. If this changes in a future solidity version, an incorrect value may be calculated. Applying parentheses would remove any ambiguity and make it easier to upgrade to future solidity releases with reduced concerns. function _getActive(uint256 configData) internal pure returns (bool) { - return configData & ~ACTIVE_MASK != 0; + return (configData & ~ACTIVE_MASK) != 0; } function _getFrozen(uint256 configData) internal pure returns (bool) { - return configData & ~FROZEN_MASK != 0; + return (configData & ~FROZEN_MASK) != 0; } function _getPaused(uint256 configData) internal pure returns (bool) { - return configData & ~PAUSED_MASK != 0; + return (configData & ~PAUSED_MASK) != 0; }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Inconsistent ERC4626 callback usage",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The default withdraw() and redeem() function implementations are overridden in AaveV2ERC4626.sol, possibly to save gas from one ERC20 token transfer. The same approach could be used for deposit() and mint() by having the user send their reserve asset directly to Aave with an onBehalfOf value in the deposit() call of the Yield Daddy vault. This may require the user to approval the Aave pool, but it would improve consistency in the Yield Daddy code.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Some hard coded variables might be better adjustable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The rewardRecipient is an address that receives accrued rewards from the ERC4626 vault. This address cannot be changed in the existing AaveV2ERC4626.sol contract. Scenarios may arise where this value needs to be changed, but the contract does not currently allow this to happen.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Unclear upgrade mechanism",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The Yield Daddy contracts have no clear upgrade mechanism even though some hard coded values might need changing in the future. Some examples of upgrade use cases include: If extra features are planned for a future Yield Daddy vault version, there is no clear path for migrating the aTokens from the existing vault. The Yield Daddy vaults do not have a mechanism to borrow from Aave using the aTokens the vault holds. Borrowing with some amount of this collateral could allow Yield Daddy to increase the yield generated and improve the value proposition to users. Introducing such a mechanism in the future would require the vault to approve the aTokens to another address or borrowing directly from Aave, and neither option is available with the contract logic. Aave had a referral program in the past which is now inactive, and a governance proposal could theoretically bring the program back. Even though this scenario is unlikely, if it were to happen the Aave deposit() call in Yield Daddy has a hard coded value of 0 for the referral code, so no referral rewards could be collected if the reward program is resumed by Aave.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. General lack of documentation and comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "To give one example of some unclear code that should have comments, the maxRedeem() function checks how much of the reserve asset is held by the aToken address. It may not be obvious to all readers that the reason that an external protocol is queried before returning a result for Yield Daddy users is to cover the edge case where the Aave pool is undercollateralized (which is common due to Aave's lending feature) and the Yield Daddy withdrawal would be larger than the entire Aave aToken reserve balance. A comment in the code or developer docs explaining this reasoning could expedite understanding for developers interfacing with this protocol or future code reviewers. Another place where NetSpec comments would help is clarifying that the return value of maxWithdraw() is in units of shares while the return value of maxRedeem() is in units of the underlying asset.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The Aave V2 factory contract has a comment accidentally copied from Aave V3. This should be modified to reference Aave V2. This comment about burn the xPYT should be removed or changed. It was erroneously copied from a similar function that does burn xPYT. The same applieds to this other comment in the same function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Aave LendingPool getConfiguration() can replace getReserveData()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "getReserveData() returns many pieces of data in Aave V2 and Aave V3. The only data needed in the wrapper contracts can be received from getConfiguration(), which returns less data in Aave V2 and Aave V3. This efficiency boost won't save gas because it is used in a view function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Redundant dependency imports",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The ERC4626 factory contracts have the same redundant import of two solmate files. For example, Aave V3 imports ERC4626Factory.sol and two solmate files. But the imported base factory contract has the solmate files imported, making the import of these files redundant. StETHERC4626.sol has a similar instance of this where StETHERC4626.sol imports \"solmate/tokens/ERC20.sol\" and \"./external/IStETH.sol\", but \"solmate/tokens/ERC20.sol\" is already imported by IStETH.sol making the separate import unnecessary. CurveV2Swapper.sol has a similar instance of this where CurveV2Swapper.sol imports \"../Swapper.sol\" and \"../lib/ApproveMaxIfNeeded.sol\", but \"../lib/ApproveMaxIfNeeded.sol\" is already imported by Swapper.sol. The same applies to the solmate and timeless imports in CurveV2Swapper.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Interface doesn't match mainnet contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "This is the Compound code defining the mintGuardianPaused mapping as mapping(address => bool) public mintGuardianPaused. The interface for this mapping is defined as function mintGuardianPaused(ICERC20 cToken) external view returns (bool). This is problematic because the address type is not equal to the ICERC20 type. A foundry test was created to test if this type mismatch caused a revert, but the test passed without a revert. However, the custom maxMint() and maxDeposit() functions are not tested with existing tests for Compound or Aave V3.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Consider upgrade to latest solidity release",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The release notes of solidity releases since 0.8.13 describe code generation bugfixes and gas optimizations that have been introduced in the more recent releases. It would be best to use the latest release unless there is a good reason to continue using 0.8.13.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. Theoretical overflow of convertToShares() and convertToAssets()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "Below is the custom convertToShares() function from StETHERC4626.sol: function convertToShares(uint256 assets) public view virtual override returns (uint256) { uint256 supply = stETH().totalSupply(); return supply == 0 ? assets : assets.mulDivDown(stETH().getTotalShares(), supply); } If the value of the assets input parameter or the value of stETH().getTotalShares() is very close to type(uint256).max at the same time that supply is a very small value, this function could revert during the mulDivDown library call. The same is true of the convertToShares() function in the standard solmate implementation. The convertToAssets() function suffers from the same side effect in this extreme case.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. No zero address checks in constructor",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "The xPYT.sol constructor sets three state variables to specific external contract addresses. No zero address check is performed, making it possible that one of these state variables could be set to the zero address.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Modify Gate.sol claimYieldAndEnter() function argument",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "Most locations where xPYT is used, it is cast to an address with address(xPYT). Only once is it used as IxPYT type. Instead, take in a function argument of type address and cast to IxPYT the one time that this type is needed.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. CurveV2xPYT utilizes a non-TWAP price oracle",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "Curve's price_oracle() implementation uses an exponential moving average for its oracle. EMA oracles have different properties from TWAP oracles, most notable of which is they are more sensitive to high price volatility near the time of query.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "There are many instances of the value 10000. Consider replacing this magic number with a constant internal variable named FEE_BASE. Instances are found here, here, here, and here.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "48. No timelock or other protection around changing fee or fee recipient",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "ownerSetProtocolFee() allows the owner to set the fee percentage and fee recipient. While this function has access control to only allow the owner to call this function, there is no further controls to reduce centralization risk. Whether this is necessary depends on the parties who are intended to receive the fees. If users are intended to receive a fraction of the fees from Swapper.sol, they may want additional guarantees that the fees will not be redirected somewhere else without notice.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "49. safeApprove is deprecated",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "This function is deprecated because it can be used to manipulate a user's allowances using specific transaction ordering.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "50. Swapper repo foundry coverage failing",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "While increasing code coverage does not necessarily reduce the risk of security issues, it is generally a good idea to improve code coverage for projects. Running foundry coverage in the swapper repo returns a CompilerError: Stack too deep when compiling inline assembly: Variable value0 is 1 slot(s) too deep inside the stack. error. This implies that code coverage is not being monitored or improved for the swapper issue.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "51. StETHERC4626.t.sol test failing",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "description": "This issue is caused by the mintUnderlying call on line 188, which mints 1e18+2 of the underlying token for alice. 1e18 of these tokens are deposited to the vault on line 201, leaving behind 2 underlying tokens in alice's account when the following assertion is made on line 205.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. staking.unstake() should set rebasing bool to true",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "The steps that the YieldStreamer functions take to withdraw yield to stream tokens occur in this order Calculate yield in gOHM Unwrap gOHM to sOHM Unstake sOHM to OHM Convert OHM to stream token The problem is in step 3. The rebasing bool is set to false, which will cause the staking contract to take gOHM from msg.sender instead of taking sOHM as the YieldStreamer contract requires. The logic for the rebasing boolean in the staking contract is if (_rebasing) { sOHM.safeTransferFrom(msg.sender, address(this), _amount); amount_ = amount_.add(bounty); } else { gOHM.burn(msg.sender, _amount); // amount was given in gOHM terms amount_ = gOHM.balanceFrom(amount_).add(bounty); // convert amount to OHM terms & add bounty } In order to convert sOHM to OHM in the staking.unstake() function, which is required in step 3 of the steps outlined above, the rebasing parameter must be set to true. Otherwise gOHM will be converted instead. https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/Staking.sol#L181 Currently the rebasing boolean value is set to false in two locations https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L246 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L322",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Sandwich attack risk in YieldStreamer.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "This code is how the swap is performed in YieldStreamer.sol in two locations: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L248-L255 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L324-L331 uint256[] memory calculatedAmounts = sushiRouter.getAmountsOut(totalOhmToSwap, sushiRouterPath); uint256[] memory amounts = sushiRouter.swapExactTokensForTokens( totalOhmToSwap, (calculatedAmounts[1] * (1000000 - maxSwapSlippagePercent)) / 1000000, sushiRouterPath, msg.sender, block.timestamp ); The amountOutMin value is the output of getAmountsOut(totalOhmToSwap, sushiRouterPath) minus some slippage percent maxSwapSlippagePercent. Examining the code of the swapExactTokensForTokens() function, we can see how amountOutMin is used. There is a check to confirm the result of the exchange is greater than the amountOutMin https://github.com/sushiswap/sushiswap/blob/56cedd0e06a6cf665083b3a662f9f77b80303ebe/contracts/uniswapv2/UniswapV2Router02.sol#L233 amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'); But because the swapExactTokensForTokens() function is using the exact same getAmountsOut() function that was used in YieldStreamer.sol to calculate amountOutMin and is calculated in the same transaction, the result is that the two getAmountsOut() output values will always be equal. So the amountOutMin set in YieldStreamer.sol serves no purpose because it can never yield a result where the amountOutMin value reverts the swap, because amountOutMin is getAmountsOut() minus some slippage, which will always be less than or equal to getAmountsOut(). The current calculation to provide an amountOutMin value is a waste of gas. Even in a scenario where a private relay is used, miners cannot guarantee that a block will not become an uncle block. If the block is uncled, the mempool data becomes public and an uncle bandit attack is possible.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Denial of service in upkeep \"for\" loop in YieldStreamer.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "This code is how the swap is performed in YieldStreamer.sol in two locations: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L248-L255 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L324-L331 uint256[] memory calculatedAmounts = sushiRouter.getAmountsOut(totalOhmToSwap, sushiRouterPath); uint256[] memory amounts = sushiRouter.swapExactTokensForTokens( totalOhmToSwap, (calculatedAmounts[1] * (1000000 - maxSwapSlippagePercent)) / 1000000, sushiRouterPath, msg.sender, block.timestamp ); The amountOutMin value is the output of getAmountsOut(totalOhmToSwap, sushiRouterPath) minus some slippage percent maxSwapSlippagePercent. Examining the code of the swapExactTokensForTokens() function, we can see how amountOutMin is used. There is a check to confirm the result of the exchange is greater than the amountOutMin https://github.com/sushiswap/sushiswap/blob/56cedd0e06a6cf665083b3a662f9f77b80303ebe/contracts/uniswapv2/UniswapV2Router02.sol#L233 amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'); But because the swapExactTokensForTokens() function is using the exact same getAmountsOut() function that was used in YieldStreamer.sol to calculate amountOutMin and is calculated in the same transaction, the result is that the two getAmountsOut() output values will always be equal. So the amountOutMin set in YieldStreamer.sol serves no purpose because it can never yield a result where the amountOutMin value reverts the swap, because amountOutMin is getAmountsOut() minus some slippage, which will always be less than or equal to getAmountsOut(). The current calculation to provide an amountOutMin value is a waste of gas. Even in a scenario where a private relay is used, miners cannot guarantee that a block will not become an uncle block. If the block is uncled, the mempool data becomes public and an uncle bandit attack is possible.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. donatedTo and depositsTo only return the first of N possible donation or deposit mappings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldDirector.sol#L195 https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldDirector.sol#L256",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. _redeemAll() does not delete recipientLookup",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "In the _redeem() function, receiptIds.pop(); and delete recipientLookup[depositId_] are called https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L429-L455 But in the similar _redeemAll() function, there is no delete recipientLookup[depositId_]; call. https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L460-L488",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Declare function external for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L315",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Use == for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "= can be simplified to = _toAgnostic(depositInfo[depositId_].principalAmount)) { amountWithdrawn = _withdrawAllPrincipal(depositId_, msg.sender); } else { _withdrawPrincipal(depositId_, amount_, msg.sender); amountWithdrawn = amount_; } And here is the modified code with a minor gas savings. This specific gas savings may be negated if the _withdrawAllPrincipal clause is used most of the time: if (amount_",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Simplify math for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L129",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Use msg.sender for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L404",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Remove functions to save gas on deployment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "balanceTo and balanceFrom in gOHM.sol convert between sOHM and gOHM using the current index exchange rate https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/governance/gOHM.sol#L111-L127 The YieldSplitter.sol functions _fromAgnostic and _toAgnostic duplicate this functionality https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L170-L186",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Gas savings using unchecked",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L167",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Gas savings with memory variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "The _closeDeposit() function in YieldSplitter.sol uses the value \"depositInfo[id_].depositor\" twice https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L144 The _redeemAll() in YieldDirector.sol function uses the value \"depositInfo[receiptIds[index - 1]].depositor\" twice https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L460",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. redeemAll repeatedly computes index - 1",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Miscellaneous Improvement Ideas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "Examples of overlap between YieldDirector.sol and YieldStreamer.sol include: YieldDirector.sol has modifiers isInvalidDeposit, isInvalidUpdate, and isInvalidWithdrawal, but YieldStreamer.sol only checks the boolean value depositDisabled, withdrawDisabled, or upkeepDisabled. YieldStreamer.sol may benefit from the same modifiers used in YieldDirector.sol. Functions like desposit() and addToDeposit() perform almost identical actions but have different names for input parameters and different natspec comments. These could be standardized better across the two contracts. Examples of magic numbers that should be converted to constant variables are found in several places: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L436 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L445 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L251 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L318 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L327",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. updateUserMinDaiThreshold assumes Dai is used as the streamToken",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldStreamer.sol#L280",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Missing calls in scripts/deployAll.js",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "description": "Start ganache and run npx hardhat run --network localhost scripts/deployAll.js . Observe the error message stating revert Timelock is disabled, use enable. To fix, add the line await olympusTreasury.initialize(); before the calls to olympusTreasury.queueTimelock() and observe the above hardhat work.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Strategy.sol no slippage tolerance limit set on _sellRewardForWant",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "_claimAndSellRewards always passes 0 as the minOut argument to the _sellRewardForWant method, so there is no slippage tolerance limit.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. BaseStrategy.sol Missing non-zero address check in setHealthCheck",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "The function does not have a non-zero address check for its address argument. All other setter methods for address type variables in the contract have non-zero address checks.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. liquidatePosition loss recording does not record loss when _amountNeeded.sub(_liquidatedAmount) <= minWant",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "Losses are only recorded when _amountNeeded.sub(_liquidatedAmount); = minWant",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Strategy.sol Missing non-zero address check in _initializeThis",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "The function calls an external contract to get some token addresses (address _aToken, , address _debtToken) = protocolDataProvider.getReserveTokensAddresses(address(want)); and then has a non-zero address check for _aToken, but not for _debtToken.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Strategy.sol Missing invariants checks in liquidatePosition",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "In the code we see the following comments: // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount` // NOTE: Maintain invariant `_liquidatedAmount + _loss",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Strategy.sol unreachable code in prepareReturn",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "On lines 254 to 257, the if statement: if (amountRequired.sub(_debtPayment)",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Unnecessary liquidation procedures",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "On line 336 https://github.com/Yacademy-block-2/yearnV2-gen-lev-lending/blob/levgeist/contracts/Strategy.sol#L336 the function checks if the want balance is sufficient to cover the amountNeeded, this is set as wantBalance > _amountNeeded. If wantBalance is the same as _amountNeeded the strategy still has sufficient funds to cover the withdraw, meaning the logic that follows this if statement is unnecessary.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Strategy.sol & BaseStrategy.sol inefficient usage of for loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "Strategy.sol lines 199, 455, 509 and BaseStrategy.sol line 893 contain for loops that are implemented inefficiently in terms of gas for the EVM. Omitting assigning a default-zero type variable to zero, caching array's length, using ++i instead of i++ can save a good chunk of gas, especially if the loop is long running.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Regular math can be used instead of SafeMath when it is safe",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "if (totalDebt > totalAssets) { // we have losses _loss = totalDebt.sub(totalAssets); } else { // we have profit _profit = totalAssets.sub(totalDebt); }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. BaseStrategy.sol does not emit event in setHealthCheck",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "All other setter methods for address type variables in the contract emit events on state change, example: function setStrategist(address _strategist) external onlyAuthorized { require(_strategist != address(0)); strategist = _strategist; emit UpdatedStrategist(_strategist); }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Strategy.sol does not emit event in setCollateralTargets, setMinsAndMaxs, setRewardBehavior",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Strategy.sol has rewards local variable defined in a couple of places which shadows reward state variable as defined in BaseStrategy.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Strategy.sol uses now keyword in _sellRewardForWant",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "The code makes use of the now keyword in Solidity which is deprecated in future Solidity versions.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Strategy.sol estimatedTotalAssets can be declared as external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "The estimatedTotalAssets method is declared as public which should be used for method that will be called from inside of the contract, but estimatedTotalAssets isn't.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Centralised control of LP tokens on Spookyswap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "description": "As of 24/06/2022 84.6% of all Geist/FTM LP tokens are controlled by a single address as seen here: https://ftmscan.com/token/0x668ae94d0870230ac007a01b471d02b2c94ddcb9#balances this address is a MasterChef so does decentralise the system slightly, however if for whatever reason this liquidity was pulled it could result in extremely high slippage which reduces profitability of the strategy and exacerbates the chances of a sandwich attack.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Price range should be within Chainlink's range",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "PriceFeed.sol#L93",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. ETH buyer pays the gas cost of debt payments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "TokenBuyer.sol#L195, TokenBuyer.sol#L235",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Can require the basis point values to be less than 10_000",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "TokenBuyer.sol#L146-L148",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Use a two-step Ownership transfer pattern",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "TokenBuyer.sol, Payer.sol",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Existing debts should be prioritized in sendOrRegisterDebt()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "Payer.sol#L100",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Risk of USDC depeg",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "DeployTokenBuyer.s.sol",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Fee-on-transfer token not supported",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "TokenBuyer.sol",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Replace owner() with msg.sender in withdrawPaymentToken()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "Payer.sol#L123",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Cache totalDebt in payBackDebt()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "Payer.sol#L158, Payer.sol#L173",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use _debtAmount instead of debt.amount",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "Payer.sol#L146-L152",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. DebtQueue.empty() can just check for equality",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "DebtQueue.sol#L112",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Precompute decimal factor to save gas and avoid magic numbers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "TokenBuyer.sol#L292, TokenBuyer.sol#L323",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. TokenBuyer may not use the entire received amount to pay the debt",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "TokenBuyer.sol#L235-L237",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. TokenBuyer's constructor can fetch paymentToken from payer",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "TokenBuyer.sol#L153",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. DebtDeque's _begin and _end can be uint128",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "DebtQueue.sol#L30-L44",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Review tokens before supporting them via TokenBuyer",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "Repo",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. onlyAdmin() is not used",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "TokenBuyer.sol#L120-L125",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Consider solidity 0.8.16 or higher",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "Example: TokenBuyer.sol#L16",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Consider adding events for creating and paying back the debt if the debt is paid back on creation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "description": "Payer.sol#L100",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Double voting using cross-chain voting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The process a staker would take to double vote with their assets is: Vote on the first chain (can be Ethereum mainnet or Polygon) Take the 15% instant withdrawal fee Bridge assets Restake GET to receive xGET Vote again on the second chain The end result is 85% more votes than should be possible from the original asset value There is even more complexity involved in cross-chain voting. Some other cases to consider are: The argument could be made that no user would want to lose 15% of their assets to get extra votes. This would depend on the bribe market and other factors, but there is also a way for the user to recapture some of their \"lost\" 15%. If a user has X amount of assets staked in the vault, 10% of the total amount could be used for this cross-chain double voting while the other 90% of the assets reclaim some of the \"lost\" 15% because the 15% fee is distributed among the stakers in the vault. To take this to the next level, a user who knows they will be performing an instant withdrawal can borrow GET at a certain interest rate, stake it, take the 15% instant withdrawal fee hit, and later withdraw the borrowed GET potentially at a profit before returning it to the borrower. Some modeling or linear programming is necessary to determine exactly when recapturing the 15% fee is profitable, especially in the scenario involving borrowed GET, which will not be examined further here. If a snapshot of user assets at a specific block is used to determine votes held by each address, the question is how to synchronize this point in time across chains. It is unlikely such a process would be exact, given that mining a block is not an instant process. If there is a different in snapshot times between Ethereum mainnet and Polygon, it may enable time for assets to be bridged across chains to enable this double voting. The exact plans around how this would work were not outlined in the smart contract and are not in scope of this review, but should be considered.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Withdraw and cancel requests can be frontrun for profit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "In the following test example, Alice deposits funds, profits are scheduled, and Alice makes a withdrawal request while funds are being streamed. Right before the executeWithdrawalRequest() is triggered by Alice, Bob deposits funds, and he will be able to get the profits immediately. Because Alice executeWithdrawalRequest() is triggered right after the deposit, the leftover profits from the duration of the lockTime are distributed to everyone, including Bob, immediately through the burn of shares. In the test, we compare the shares with Eve's shares. Eve deposited right after Alice's withdrawal. They are very different from the amount of Bob shares's. The share amount is very different because the price per share has dramatically increased. function testFrontRunWithdraw() public { address eve = address(0x0E5E); // first Alice deposit _setUpDepositor(alice, 1 ether); // We add some profit asset.mint(address(vault), 1 ether); vault.updateVestingSchedule(); vm.warp(block.timestamp + 2 days); // Alice starts a withdrawal request vault.createWithdrawalRequest(1 ether); // we increase time to reach the end of the lock vm.warp(block.timestamp + 26 weeks); // Bob deposit _setUpDepositor(bob, 1 ether); vm.stopPrank(); // Alice execute the withdraw vm.startPrank(alice); vault.executeWithdrawalRequest(0); // Eve deposit vm.stopPrank(); _setUpDepositor(eve, 1 ether); vm.stopPrank(); assertApproxEqRel(vault.balanceOf(eve), vault.balanceOf(bob), 10e6); } function convertToAssets(uint256 shares_) public view virtual override returns (uint256 assets_) { uint256 supply = totalSupply; // Cache to stack. assets_ = supply == 0 ? shares_ : (shares_ * totalAssets()) / supply; }",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Vault may be susceptible to donation attack",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The first user to call deposit() on the GovernanceLockedRevenueDistributionToken.sol contract is issued the same quantity of shares as the underlying assets they provide. A user can abuse this to deposit a single quantity of assets in return for one share, setting the supply to 1. This same user could then send a large donation of underlying assets to the vault through a direct transfer and call the updateVestingSchedule() function to begin increasing the totalAssets() value. The ability to call updateVestingSchedule() after a donation is a requisite for this attack due to the totalAssets() value relying on the issuanceRate. The required capital for a successful donation attack will diminish over the course of a 14 day period. The below POC can be added to Compound.t.sol to show the donation amount needed to round another depositor's share issuance to 0 after 1 day has passed between deposits: function testDonationAttack() public { // after set up, allow alice to withdraw all but a dust amount from the vault // we warp ahead in time to avoid withdrawal penalties to ensure the vault is left with only dust vm.startPrank(alice); uint256 allButDust = 1 ether - 1; vault.createWithdrawalRequest((allButDust)); uint256 afterWithdrawalPenalties = start + 26 weeks; vm.warp(afterWithdrawalPenalties); // execute the withdrawal request vault.executeWithdrawalRequest(0); vm.stopPrank(); // print out the shares that would be minted from 1 ether console.log(\"1 ether deposit before donation attack yields _%s_ shares.\", vault.previewDeposit(1 ether)); // provide bob with starting capital asset.mint(bob, 14 ether + 1); // bob performs the donation. With a 1 day wait, it will require 14 times the capital of the other user to issue 0 shares // this is because the vesting schedule follows a linear issuance mechanism over the course of 14 days vm.startPrank(bob); asset.transfer(address(vault), 14 ether + 1); // call the update vesting schedule and wait 1 day for issuance rate to increase vault.updateVestingSchedule(); vm.warp(afterWithdrawalPenalties + (1 days)); // demonstrate that a user who wishes to deposit 1 ether will now be minted 0 shares console.log(\"1 ether deposit after donation attack yields _%s_ shares.\", vault.previewDeposit(1 ether)); }",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Redistribute event emits incorrect value and could underflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "Within the executeWithdrawalRequest() function, a user's withdrawal request is processed, shares are transferred from the vault to the user, and the equivalent number of the user's shares are burned. When this internal _burn() function is called, the issuanceRate, totalAssets(), and supply values change. The Redistribute event is then emitted and the value it calculates in its convertToAssets() call is significantly impacted by these changes. Adding the following POC to InstantWithdrawal.t.sol demonstrates that the skewed value can even prevent the last share(s) from being withdrawn from the vault due to an arithmetic underflow: function testExecuteWithdrawalRedistributeUnderflow() public { // Alice deposits 1 ether of underlying asset to the vault // Bob deposits 2 ether of underlying asset to the vault _setUpDepositor(alice, 1 ether); _setUpDepositor(bob, 2 ether); // Allow bob to redeem early as seen in the instantWithdrawalFeeSharing test // This leaves positive yield in the vault for alice vault.redeem(vault.balanceOf(bob), bob, bob); uint256 bobFee_ = _instantWithdrawalFee(2 ether); // == 0.3 ether assertEq(asset.balanceOf(bob), 2 ether - bobFee_); vm.stopPrank(); // Attempt to withdraw our balance as alice // This will throw an arithmetic underflow due to the incorrect calculation in // The Redistribute event vm.startPrank(alice); vault.createWithdrawalRequest(vault.balanceOf(alice)); vault.executeWithdrawalRequest(0); vm.stopPrank(); }",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Incorrect _burn function in cancelWithdrawalRequest()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The standard ERC20 _burn() function with two function arguments exists in the contracts inherited from the ERC20 contract, but RevenueDistributionToken has a _burn() function with five function arguments. The latter is what is normally called in LockedRevenueDistributionToken (1, 2, 3) except for in cancelWithdrawalRequest(). The purpose of line 137 is to burn any excess shares beyond what is returned to the staker cancelling their withdrawal request, because in this case the staker will receive the same value of shares (priced in underlying assets) as when they deposited, but this may be a lesser number of shares than they submitted a withdrawal request for. Phrased another way, the accrued value that the shares gained while the contract held the shares is returned to the vault to be shared among shareholders. When the value in the vault has changed, the value of each share should change by updating freeAssets and issuanceRate. But freeAssets and issuanceRate are not updated when _burn() with two function arguments is called. So after cancelWithdrawalRequest() is called, freeAssets and issuanceRate may not be accurate. Specifically, freeAssets could be overinflated by convertToAssets(burnShares_). And if the _burn happens after vestingPeriodFinish, the issuanceRate will not be updated to zero, meaning the return value of totalAssets() would not be accurate.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. updateVestingSchedule() may not be called on time",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "There are two closely related issues here: updateVestingSchedule() can be called any time within 24 hours of vestingPeriodFinish. The optimal strategy for calling updateVestingSchedule() from the perspective of a staker who will withdraw from the vault if the yield is any lower is to 1. call updateVestingSchedule() as soon as possible if issuanceRate will increase from its current value (the rate of rewards distribution increases) or 2. delay calling updateVestingSchedule() until vestingPeriodFinish if issuanceRate will decrease. The issue here is that by delaying the updateVestingSchedule() call, the function may not be called until after vestingPeriodFinish. It may be even further delayed if gas is very high and the staker(s) running bots to automatically call the function determine that the \"lost yield\" from the time where issuanceRate is zero is less than the gas cost of calling vestingPeriodFinish. This is possible because the staker(s) running bots may not have a large number of vault shares. issuanceRate can only be changed in updateVestingSchedule() except when block.timestamp > vestingPeriodFinish. When block.timestamp > vestingPeriodFinish, issuanceRate can be set to zero when the _burn() or _mint() RevenueDistributionToken functions are called. This could be done accidentally, with a normal user wishing to stake into the vault who unknowingly sets issuanceRate to zero while staking their GET. Even if issuanceRate is non-zero, rewards will not be distributed after vestingPeriodFinish due to the math in totalAssets(). Any time that vestingPeriodFinish is less than the current block.timestamp is a zero yield scenario for stakers. In short, an issuanceRate of zero is not good for stakers, but there is a question of who will call updateVestingSchedule() and when they will call it. Competing incentives and a lack of integration with a keeper system like Gelato may result in non-ideal scenarios for all stakers.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. External call made to non-existent permit function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The mintWithPermit() and depositWithPermit() functions are intended to allow users to transfer assets to the vault in a single transaction. To achieve this, these functions call permit on the underlying asset with a user's signature that was gathered off-chain. However, the vault's underlying asset is intended to be GET which does not contain a permit function on Ethereum or Polygon.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Vault lacks slippage protection",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "When an EOA user wants to participate in staking with the vault, they can check what the current exchange rate of their GET and/or xGET will be using functions such as previewDeposit(). Since they are an EOA, they must then wait for this transaction to be mined for it to return results before they can post a new transaction acting on this information. There is no guarantee that the previously returned exchange rate will be the same and in fact it could be drastically different. There are numerous reasons a price change may occur, such as from exploitative front-run attempts, reward distributions, or even the ratio completely resetting if all of the shares have been removed from the vault. ERC-4626 alludes to this issue in its security considerations, and many other protocols in the ecosystem that offer swaps and exchanges have slippage protection mechanisms for their users.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Unsafe casting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "OpenZeppelin uses SafeCast in functions like numCheckpoints(), getCurrentVotes(), and getPriorVotes() to prevent overflows due to casting. GovernanceLockedRevenueDistributionToken.sol has similar implementations of numCheckpoints(), getCurrentVotes(), and getPriorVotes() but without SafeCast. The SafeCast library protects against overflows when casting from a large int value to a small int value, and GovernanceLockedRevenueDistributionToken.sol doesn't have any casting overflow protection in the existing contract. A comparison of the numCheckpoints() implementation is compared below. function numCheckpoints(address account_) public view virtual override returns (uint32 numCheckpoints_) { - numCheckpoints_ = uint32(userCheckpoints[account_].length); // this is the GovernanceLockedRevenueDistributionToken.sol implementation + numCheckpoints_ = SafeCast.toUint32(_checkpoints[account].length); // this is how OpenZeppelin implements the casting }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. previewWithdrawalRequest() may return incorrect user's request",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "Regardless of what value for owner_ is passed to the previewWithdrawalRequest(), the withdrawal request is gathered based on the msg.sender. The owner_ value is then used to determine if this request should be fee exempt or not. This incorrectly associates the withdrawal request and any corresponding fee exemptions. Adding the following POC to InstantWithdrawal.t.sol demonstrates the issue: function testIncorrectPreviewWithdrawal() public { // Exempt bob from fees vault.setWithdrawalFeeExemption(bob, true); // Create a deposit and withdrawal request for 2 ether for Bob // This should be fee exempt _setUpDepositor(bob, 2 ether); vault.createWithdrawalRequest(vault.balanceOf(bob)); // Create a deposit and withdrawal request for 1 ether for Alice // This should not be fee exempt // Note that the current prank is now using alice's context _setUpDepositor(alice, 1 ether); vault.createWithdrawalRequest(vault.balanceOf(alice)); // Bob should have no withdrawal fees and a balance of 2 ether // so we would expect this to return 2 ether. Instead it returns 1 ether // which is a combination of Alice's withdrawal request and bob's fee exemption (, uint256 bobWithdrawAmount, uint256 bobFee) = vault.previewWithdrawalRequest(0, bob); console.log(\"Amount to withdraw: %s\", bobWithdrawAmount); }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Withdrawal requests incentivized if issuanceRate is zero",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "When a withdrawal request is created, the contract takes and holds the staker's shares until the withdrawal is executed or canceled. The staker receives no interest or yield while the contract holds the shares. But if the interest or yield is zero, stakers are incentivized to submit a withdrawal request because there are no rewards to miss out on when the contract holds the shares, which happens when issuanceRate is zero.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Lack of issuance rate synchronization across chains may lead to uneven voting rewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "Voting power is denominated in the underlying assets (GET) as opposed to the vault's shares (xGET) to better facilitate voting across chains. This way, stakers on a vault with a lower share to underlying asset exchange rate are not necessarily penalized (as far as voting is concerned). This does not necessarily hold true for reward distribution. Rewards are granted through a vesting schedule whereby an issuanceRate is calculated to issue rewards linearly throughout the vesting period. Since rewards are issued in GET, higher issuanceRate vaults may reward their stakers with more voting power.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Incorrect value getVotes(address account)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The function is changed from standard one to include additional votes that will be available after the next action from the user. Only after the user write action a new checkpoint is stored for him, with a new vote value.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Lack of input sanitization in the constructor function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The variables instantWithdrawalFee and lockTime are not checked to be valid in the constructor. constructor( string memory name_, string memory symbol_, address owner_, address asset_, uint256 precision_, uint256 instantWithdrawalFee_, uint256 lockTime_ ) RevenueDistributionToken(name_, symbol_, owner_, asset_, precision_) { instantWithdrawalFee = instantWithdrawalFee_; lockTime = lockTime_; } LockedRevenueDistributionToken.sol#L55-L56",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Add require statement in updateVestingSchedule",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The function updateVestingSchedule allows anyone to update the vesting schedule even if the issuanceRate_ is zero.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Avoid && logic in require statements",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "One instance of require with && logic was found.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "Require statements are used in the strategy and error messages are not used anywhere. Using this new solidity feature can provide gas savings on revert conditions.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "There is at least one location where unchecked can be applied + unchecked { return high_ == 0 ? 0 : (isVotes_ ? _unsafeAccess(ckpts, high_ - 1).votes : _unsafeAccess(ckpts, high_ - 1).shares); + } There is another example of a subtraction operation that can use unchecked for gas savings in LockedRevenueDistributionToken. if (withdrawalFeeExemptions[owner_] || request_.unlockedAt",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Make DELEGATE_TYPEHASH private",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "DELEGATE_TYPEHASH is a private constant in the OpenZeppelin contract that the GET contract is based on. This variable is public in the GET GovernanceLockedRevenueDistributionToken.sol contract. Note this has been applied to PERMIT_TYPEHASH already, which is public in OpenZeppelin but private in GET.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Duplicate zero check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "_mint() is always called with the argument shares_ = previewDeposit(assets_) or with assets_ = previewMint(shares_). previewDeposit() rounds down while previewMint() rounds up. This means if assets_ is zero, shares_ will be zero, but it is possible for shares_ to be zero when assets_ is non-zero. Therefore the weaker check of assets_ can be removed. The same change can be made to _burn().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Duplicate balance check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "createWithdrawalRequest() checks if msg.sender has sufficient shares balance, but the ERC20 transfer a few lines later effectively does the same check, because this subtraction would revert if msg.sender has insufficient shares balance.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Make variables immutable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The asset state variable in the constructor of RevenueDistributionToken can be declared immutable. In addition, ERC20.sol symbol and name aren't changed after the contract is initialized so they can be immutable.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Make functions external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "getPastTotalSupply() is never called in GovernanceLockedRevenueDistributionToken and can be external instead of public. The change could be applied to delegate() too.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Make variables uint32",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "instantWithdrawalFee and lockTime have hard coded maximum values of 100 and MAXIMUM_LOCK_TIME (or 62899200) respectively. These variables are of uint256 type but can be defined as uint32. The same approach can be taken with the constant values MAXIMUM_LOCK_TIME, VESTING_PERIOD, and WITHDRAWAL_WINDOW in the same contract.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Transfer isn't necessary before calling _burn()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "Burn can be performed without the transfer: - _transfer(address(this), msg.sender, request_.shares); - _burn(request_.shares, assets_, msg.sender, msg.sender, msg.sender); + _burn(request_.shares, assets_, msg.sender, address(this), address(this)); LockedRevenueDistributionToken.sol#L159",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Unnecessary nonReentrant protection",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The following functions have an unnecessary non-reentrant check: RevenueDistributionToken.sol#L99 RevenueDistributionToken.sol#111 RevenueDistributionToken.sol#L117 RevenueDistributionToken.sol#L130 RevenueDistributionToken.sol#L138 RevenueDistributionToken.sol#L142 LockedRevenueDistributionToken.sol#L110 LockedRevenueDistributionToken.sol#L127 LockedRevenueDistributionToken.sol#L152 LockedRevenueDistributionToken.sol#L205",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Replace != with >",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "In updateVestingSchedule, instead of using != in L181 > can be used for minor gas savings. - require(totalSupply != 0, \"LRDT:UVS:ZERO_SUPPLY\"); + require(totalSupply > 0, \"LRDT:UVS:ZERO_SUPPLY\");",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Emit memory variables in events instead of storage",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "In following functions, memory variables can be emitted in events instead of global. setInstantWithdrawalFee - emit InstantWithdrawalFeeChanged(instantWithdrawalFee); + emit InstantWithdrawalFeeChanged(percentage_); setLockTime - emit LockTimeChanged(lockTime); + emit LockTimeChanged(lockTime_);",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Usage of booleans for storage incurs overhead",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "In the LockedRevenueDistributionToken.sol file, the withdrawalFeeExemptions mapping maps user address with a boolean flag to indicate fee exemption, which could cost some additional gas. In solidity, booleans (bool) are a bit expensive to use in comparison to other data types because each bool value is stored in a single byte. This means that each bool value requires at least one gas unit to be read or written. In comparison, other data types like uint (unsigned integer) can be stored in much less space, allowing for more efficient use of gas. It's generally more efficient to use other data types, like uint, whenever possible. Read more here: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Redundant imports can be removed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "GovernanceLockedRevenueDistributionToken.sol imports ERC20.sol. But the ERC20.sol import already exists in LockedRevenueDistributionToken.sol and in RevenueDistributionToken.sol. The ERC20.sol import can be removed from GovernanceLockedRevenueDistributionToken.sol and from LockedRevenueDistributionToken.sol because it will be included from RevenueDistributionToken.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Clarify order of operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The Math library is based on OpenZeppelin's Math library. The OpenZeppelin library has parenthesis on these lines but the GET Math library doesn't have these. No issue is expected here, but clarifying the order of operations can make the code easier for readers to understand and make upgrades to future version of solidity less problematic in case the compiler has changes made to the order of operations.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Operational order during minting could be improved",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "When a user makes a deposit call in the RevenueDistributionToken.sol contract, the underlying _mint() function with 4 parameters is called. Inside of this function, the user is given their shares before they officially transfer in the underlying asset to the vault. If reentrancy were to occur in a before token transfer hook during this transferFrom call, the vault would have issued shares without receiving assets in return at that point in time. Reordering these operations may make it possible to remove the nonReentrant modifiers on functions that call _mint().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Abandoned withdrawal shares are irretrievable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "After createWithdrawalRequest() is called, the contract takes possession of the user's shares. But the contract has no way of redeeming these shares that it holds, and there is no time limit for shares to be considered \"abandoned\" or \"forfeited\" if left in the contract. This may be similar to a user transferring their shares to an inaccessible random address, except: The contract holding the shares is the ERC4626 vault contract itself The ERC4626 vault cannot do anything with these shares The user can retrieve these shares if the want, unlike sending them to an irretrievable address",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Shares escrowed for withdrawal can't vote",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The GET Locked Revenue Distribution token contracts hold shares that are waiting to be withdrawn, but these shares are not able to be used for voting because the contract never delegates these shares. Because there is no quorum, this is unlikely to result in altering the outcome of a vote directly, but it would make it easier to potentially swing a vote because the shares held in escrow during the withdrawal process will not vote.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Improve function and variable names",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "createWithdrawalRequest() takes a function argument of shares and returns a value in units of assets, but the standard ERC4626 withdraw() does the opposite by taking assets as a function argument and returning a value in units of shares. Instead, the function might be better named createRedeemRequest() if it is going to take a function argument of shares to match the ERC4626 redeem() function. totalAssets_ found in previewRedeem() and previewWithdraw() doesn't related to the return value of totalAssets(). It might be better named preFeeAssets_ or assetsPlusFee_. The Checkpoint array function argument is named ckpts, but this is the same name as the state variable ckpts. Consider removing this function argument if the same state variable will always be accessed when _unsafeAccess() is called.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Use actual GET token contract for tests",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "Since the GET token is the ERC20 token that the tests care about, consider using the GET contract code directly. The tests can use a fork of mainnet to use the on-chain contract, or the relevant contract code could be imported. If testing on a fork, consider testing on mainnet and Polygon, the two places where these contracts are planned to be deployed.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Documentation nitpicks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The Governance section makes no mention of this crucial nuance in the governance logic - that the staker must \"delegate to themselves in order to activate checkpoints and have their voting power tracked\". The list of state variables that can be controlled by governance votes is either incomplete or omits variables that can be changed by the owner outside of governance votes. Specifically, setPendingOwner() and updateVestingSchedule() are not in the list.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Conversion calculations not protected from shadow overflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "In an expression such as uint256 D = A * B / C, Solidity will attempt to store the intermediary result of A * B before it performs the division by C. If this overflows, then the transaction will revert. The muldiv technique was created to prevent the possibility of an intermediary overflow on calculations that perform both multiplication and division.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Inaccurate comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "updateVestingSchedule() has a misleading comment description and a typo that misspelled \"Identical\" as \"Intentical\".",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Mainnet deposit delay incentivized due to bridging delay",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The GET token contract on Ethereum is where GET can be minted, but there is a GET contract on Polygon that is properly mapped and registered with Polygon. The GET token is bridged using the Polygon PoS Bridge, which Polygon docs describe as having a delay of 20 minutes to 3 hours. When GET is bridged across by the bridging contract, stakers will be able to see that rewards are going to arrive soon to the xGET contract on mainnet. The prospective stakers may delay the start of their staking for the amount of time it takes for the assets to bridge and earn yield elsewhere during that time.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Influence of blockchain data on xGET rewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "Because GET tickets are NFTs, the sales of those tickets are visible in real-time. The sales of the tickets may provide insight into the future yield that could be earned by stakers. This is not a security concern per se, but may influence the decision making of stakers to stake sooner or later based on this information and depending on how rewards are transmitted to the contract.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Partial comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "The function is defined in GovernanceLockedRevenueDistributionToken: https://github.com/GETProtocolDAO/locked-revenue-distribution-token/blob/ab272ced94d6bc8cc1ded2664408a3fa7ce67128/src/GovernanceLockedRevenueDistributionToken.sol#L300.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. issuanceRate_ is scaled up",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "issuanceRate_ is scaled up using precision.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. Use named constants instead of magic numbers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "100 in the following instances should use a constant variable instead: LockedRevenueDistributionToken.sol#L68 LockedRevenueDistributionToken.sol#L265 LockedRevenueDistributionToken.sol#L292 LockedRevenueDistributionToken.sol#L135",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Silence compiler warning for unused variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "If any function param is not used, do not declare that param with a name in functions maxDeposit, maxMint. For e.g., - function maxDeposit(address receiver_) + function maxDeposit(address)",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. Use the latest Solidity version with a stable pragma",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "Using a stable pragma ensures that the contract will continue to function as intended even if there are breaking changes in future versions of Solidity. By using a stable pragma, the contract will be locked to a specific version of Solidity, which can help to prevent unexpected behavior or errors if the contract is compiled with a newer version of the compiler. Also consider using the latest version of Solidity since it will include the most up-to-date features, enhancements, and bug fixes, which can help to make the contract more efficient and secure.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Delete doesn't reduce the size of the array",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "description": "delete userWithdrawalRequests[msg.sender][pos_]; LockedRevenueDistributionToken.sol#L131 (LockedRevenueDistributionToken.sol#L157)[https://github.com/GETProtocolDAO/locked-revenue-distribution-token/blob/ab272ced94d6bc8cc1ded2664408a3fa7ce67128/src/LockedRevenueDistributionToken.sol#L157]",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Incorrect transfer of funds on token exit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md",
        "description": "Calling exitToToken(ExitQuoteData calldata quoteData, address recipient) user can define address recipient to receive the funds but this address is ignored and all funds are sent to the message sender instead.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Avoid double checking",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md",
        "description": "At L222 there is a check for condition reserveTokenAmount != 0, which already checked at L213.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Incorrect comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md",
        "description": "File MintableToken has a comment with an incorrect function accessibility.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Governable and GovernableUpgradeable should abstract common code into a common contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Infinite withdrawals using function withdrawAllWithRedirect(uint256 _id)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "In the following example, Bob can withdraw all tokens in the contract. The first call only withdraws the funds allocated to him, but because it's not recorded, Bob can call withdraw again. Here's an extended test. function testWithdrawAllWithRedirect() external { vm.prank(alice); llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 10000000 ); vm.prank(bob); llamaPayV2Payer.addRedirectStream(0, steve); vm.warp(15000); vm.prank(bob); llamaPayV2Payer.withdrawAllWithRedirect(0); (uint256 balance, , , uint48 lastUpdate) = llamaPayV2Payer.tokens( address(llamaToken) ); assertEq(llamaToken.balanceOf(address(llamaPayV2Payer)), 5000 * 1e18); assertEq(llamaToken.balanceOf(steve), 5000 * 1e18); assertEq(balance, 5000 * 1e20); assertEq(lastUpdate, 15000); // redeemables should be 0 but it's not assertGt(llamaPayV2Payer.redeemables(0), 0); // Withdraw all again vm.prank(bob); llamaPayV2Payer.withdrawAllWithRedirect(0); assertEq(llamaToken.balanceOf(address(llamaPayV2Payer)), 0); assertEq(llamaToken.balanceOf(steve), 2 * 5000 * 1e18); assertEq(lastUpdate, 15000); // redeemables should be 0 but it's not assertGt(llamaPayV2Payer.redeemables(0), 0); }",
        "labels": [
            "yAudit",
            "Severity: Critical",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Inaccurate internal token balance for weird ERC20 tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "When a token is deposited into LlamaPayV2Payer, the internal balance is updated and the transfer of tokens into the contract happens. The key lines are: tokens[_token].balance += _amount * tokens[_token].divisor; token.safeTransferFrom(msg.sender, address(this), _amount); The problem is that if a fee-on-transfer exists, the tokens[_token].balance will be greater than the balanceOf token amount in the contract, because the tokens[_token].balance did not subtract the fee-on-transfer amount. A receiver could withdraw more tokens than they should have access to with these steps: The payer deposits X number of fee-on-transfer tokens into the LlamaPayV2Payer contract The internal balance thinks the contract holds X tokens, but actually the contract holds X - tokenFee tokens The contract accounting does not consider the fee involved for fee-on-transfer tokens. If the receiver is eligible to withdraw the X amount of tokens, they can only withdraw X - tokenFee tokens because this is the amount held by the contract. If fee-on-transfer tokens are permitted, the accounting should only permit a withdrawal of X - tokenFee. The payer deposits Y number of fee-on-transfer tokens into the LlamaPayV2Payer contract. If X - tokenFee + Y - tokenFee > X, then the receiver can now withdraw the X amount of tokens because the contract holds enough tokens to allow this withdrawal. If fee-on-transfer tokens are permitted, the accounting should only permit a withdrawal of X - tokenFee, but with the current code, the receiver with withdraw X tokens. Likewise, if a rebasing token is used and the balanceOf token amount in the contract is a function of time, the tokens[_token].balance value is not increased or decreased outside of deposit or withdraw events and therefore the internal accounting may underestimate the tokens held by the contract. This latter case could lock funds in the contract, for example: The payer deposits X number of rebasing tokens into the LlamaPayV2Payer contract Over time, the X rebasing tokens grow to 1.25 * X tokens Once the stream ends and the receiver can withdraw the full token balance, the internal account balance still assumes the contract holds only X tokens, so only X tokens and not 1.25 * X tokens can be withdrawn.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. burnStream() shouldn't burn a stream if it has some debt",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Alice creates a stream for Bob which ended but has some debt accrued. Some time after the stream ends, Alice decides to burn that stream. Later Bob checks that Alice has to pay some debt for stream and calls repayAllDebt() to pay the debt for that stream. But now as the stream has been burnt by Alice, Bob cannot redeem the debt from stream, and those amount of funds are locked into that stream.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Payee funds get locked if stream is resumed after being burned",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Alice (payer) creates a stream for Bob (payee), and later Alice decided to burn the stream as the payout time was over. Now later Alice decides to resume the stream to Bob, which in turns makes the stream active again. But Bob can not accesss the redeemable funds as due to the burn the ownerOf(_id) is address(0), and has not been reallocated in resumeStream(). function testBurnAndResumeStream() external { vm.startPrank(alice); // Alice creates a stream for Bob llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 50000 ); vm.warp(12000); // Alice stops the stream llamaPayV2Payer.stopStream(0, false); // Alice pays Bob llamaPayV2Payer.withdrawAll(0); // checking that bob is the owner of stream address nftOnwer = llamaPayV2Payer.ownerOf(0); assertEq(nftOnwer, bob); // Alice burns the stream llamaPayV2Payer.burnStream(0); // Alice resumes the stream, now Bob can again withdraw after some time llamaPayV2Payer.resumeStream(0); vm.warp(20000); vm.stopPrank(); // now Bob tries to withdraw from stream, which fails as the owner of nft is address(0) vm.startPrank(bob); llamaPayV2Payer.withdrawAll(0); vm.stopPrank(); }",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Llama Pay V2 is incompatible with high decimal tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "The key line is: if (tokens[_token].divisor == 0) { tokens[_token].divisor = uint208(10**(20 - token.decimals())); } If token.decimals() is greater than 20, then the subtraction 20 - token.decimals() will underflow and the transaction will revert. This prevents depositing tokens like YAM-V2 into Llama Pay V2.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. permitToken fails in case of tokens that doesn't follow IERC20Permit standard",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "permitToken() fails in case of DAI. IERC20Permit: function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external; DaiPermit: function permit( address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s ) external;",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Handle funds transferred via transfer method",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Introduce a new variable X that tracks the net amount that exist in the contract for each token. Updating LlamaPayV2Payer.sol#L183 with ERC20(token_).balanceOf(address(this)) solves this by making those extra funds withdraw-able. - uint256 toSend = token.balance / token.divisor; + uint256 toSend = (token.balance / token.divisor) + (ERC20(_token).balanceOf(address(this)) - X); Rebalance token balance in _updateToken function. function _updateToken(address _token) private { Token storage token = tokens[_token]; token.balance += (ERC20(_token).balanceOf(address(this)) - X); ... }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Missing Input Validation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "None of the external createStream functions or the internal one createStream perform input validation for the _to address. This address is supplied by the user and is the recipient of the stream token. It is not uncommon for users or front-ends/ clients to set 0 as values for input forms. This can lead to a user creating a stream but accidentally burning it in the process as well.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. _updateToken updates token.lastUpdate even if the token doesn't exists",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "function _updateToken(address _token) private { Token storage token = tokens[_token]; // @audit add this check require(token.divisor > 0, \"NOT_ADDED\"); // rest same }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. BoringBatchable.batch() is payable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "BoringBatchable.sol#L46",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. modifyStream() should revert for inactive stream",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "For example, take a stream s with id id with this configuration: s.lastPaid  s.ends s.amountPerSec == _oldAmountPerSec Now, modifyStream(id, _newAmountPerSec, _newEnd) is called for this stream with _newEnd in future. After _updateStream(), lastPaid becomes 0, and now even though the stream's end is in future, it is not streamed any funds as the stream remains inactive.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. withdrawable() can revert",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Cases where withdrawable() can revert: When no token is deposited in LlamaPayV2Payer, and a stream is created. reverts due to division by 0 as token.divisor is 0. When execution reaches in this else block, and stream.starts > lastUpdate. reverts due to arithmetic underflow. This implicitly assumes that lastUpdate lies between starts and ends.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Inaccuracies in withdrawable()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "LlamaPayV2Payer.sol#L650 LlamaPayV2Payer.sol#L603",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. streams can be resumed even after burn",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "function testBurnAndResumeStream() external { vm.startPrank(alice); llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 50000 ); vm.warp(12000); llamaPayV2Payer.stopStream(0, false); llamaPayV2Payer.withdrawAll(0); // burning the stream llamaPayV2Payer.burnStream(0); // resuming the stream llamaPayV2Payer.resumeStream(0); vm.stopPrank(); } function burnStream(uint256 _id) external { if ( msg.sender != owner && payerWhitelists[msg.sender] != 1 && msg.sender != ownerOf(_id) ) revert NOT_OWNER_OR_WHITELISTED(); /// Prevents somebody from burning an active stream or a stream with balance in it if (redeemables[_id] > 0 || streams[_id].lastPaid > 0) revert STREAM_ACTIVE_OR_REDEEMABLE(); _burn(_id); emit BurnStream(_id); } As above code shows that data related to that particular burnt _id still stays in contract, it can be again resumed.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. modifyStream can create a new stream if it doesn't exist",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Since modifyStream doesn't check whether the stream is present or not, it creates a new stream if not present. function testModifyStream() external { vm.prank(alice); llamaPayV2Payer.modifyStream(0, 2e20, 20000); (uint208 amountPerSec, , , , uint256 ends) = llamaPayV2Payer.streams( 0 ); assertEq(amountPerSec, 2e20); assertEq(ends, 20000); }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. payerWhitelists addresses should have access to all withdraw operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "withdraw(), withdrawAll(), withdrawWithRedirect(), and withdrawAllWithRedirect() do not permit an address in payerWhitelists to call them. Most likely this was an oversight, because the addresses in payerWhitelists should have similar permissions as the contract owner. The payer whitelist addresses could take funds directly from the contract already, so they should be able to assist with transfering the funds to the intended recipient.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Rogue payerWhitelists address can steal value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Any function protected by the onlyOwnerAndWhitelisted modifier treats the owner and whitelisted payer addresses as the same privilege level. This includes the internal _createStream() function that can redirect value to a recipient. If an owner deposits value into the Llamapay contract, an address in the payerWhitelists mapping can: Backrun the deposit to create a stream where the recipient is an address that is controlled by the whitelisted address. The stream end date can be in the past so that it is possible to instantly withdraw. After the stream is created, the recipient can withdraw the funds. The end result is the same as calling withdrawPayer() directly, but this is a less expected approach.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Use cheaper comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "At L251 and L280 logic can be switched to save some gas.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Incorrect function visibility",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "tokenURI() and withdrawable() should be external functions in LlamaPayV2Payer. In LlamaPayV2Factory, calculateLlamaPayAddress() should be an external function.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. owner should be a immutable variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "owner is never updated; it should be defined as an immutable to save gas.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Return stream value after updating",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "If the _updateStream(uint256 _id) is changed to return the update stream, small gas optimization is possible. At L201, L222, L243, L272, L400, L425, L446, L222 a stream value could be returned instead of loading again stream in the next line.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Unchecked can be applied to this line and other similar locations. The subtraction will not overflow because lastUpdate is zero. block.timestamp - lastUpdate has a max value of type(uint48).max and token.totalPaidPerSec has a max value of type(uint208).max, the maximum product is type(uint256).max which doesn't overflow. - uint256 streamed = (block.timestamp - lastUpdate) * token.totalPaidPerSec; + unchecked { uint256 streamed = (block.timestamp - lastUpdate) * token.totalPaidPerSec; }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Do not load whole struct if not required",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Following function loads Stream struct, but loading Stream.token works. withdrawAllWithRedirect withdrawWithRedirect withdrawAll withdraw - Stream storage stream = streams[_id]; + address token = streams[_id].token;",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Pass struct as a params to _createStream()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Update _createStream and createStream this way: function createStream( address _token, address _to, uint208 _amountPerSec, uint48 _starts, uint48 _ends ) external { uint256 id = _createStream( Stream({ amountPerSec: _amountPerSec, token: _token, lastPaid: 0, starts: _starts, ends: _ends }), _to ); emit CreateStream(id, _token, _to, _amountPerSec, _starts, _ends); } function _createStream(Stream memory stream, address _to) private onlyOwnerAndWhitelisted returns (uint256 id) { if (stream.starts >= stream.ends) revert INVALID_TIME(); _updateToken(stream.token); Token storage token = tokens[stream.token]; if (block.timestamp > token.lastUpdate) revert PAYER_IN_DEBT(); _safeMint(_to, id = nextTokenId); /// calculate owed if stream already ended on creation uint256 owed; if (block.timestamp > stream.ends) { owed = (stream.ends - stream.starts) * stream.amountPerSec; } else if (block.timestamp > stream.starts) { /// calculated owed if start is before block.timestamp owed = (block.timestamp - stream.starts) * stream.amountPerSec; tokens[stream.token].totalPaidPerSec += stream.amountPerSec; stream.lastPaid = uint48(block.timestamp); } else if (stream.starts >= block.timestamp) { /// If started at timestamp or starts in the future tokens[stream.token].totalPaidPerSec += stream.amountPerSec; stream.lastPaid = uint48(block.timestamp); } unchecked { /// If can pay owed then directly send it to payee if (token.balance >= owed) { tokens[stream.token].balance -= owed; redeemables[id] = owed; } else { /// If cannot pay debt, then add to debt and send entire balance to payee uint256 balance = token.balance; tokens[stream.token].balance = 0; debts[id] = owed - balance; redeemables[id] = balance; } nextTokenId++; streams[id] = stream; } }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. if condition can be optimized in withdrawable()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "LlamaPayV2Payer.sol#L662",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Use calldata instead of memory if function param remains unchanged",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Following function uses memory to pass string param, calldata can be used as the string remains unchanged during function execution. createStreamWithReason createStreamWithheldWithReason - string memory _reason + string calldata _reason",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Consider and compare UX when streams are ERC1155 tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "ERC1155 doesn't have the same interface as ERC721, so if doing this replacement, a code refactor may be needed. Another thing to consider would be to use ERC1155D (see this repo and announcement) which provides compatibility with ERC721 interface, however, it's not audited. So if you consider ERC1155D, you can either self-review it, take inspiration or get it audited.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Missing Indexed Event Parameters",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "All the events are missing any indexed parameters.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. External createStream functions should return the streamId",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Right now, the createStream functions namely createStream, createStreamWithReason, createStreamWithheld and createStreamWithheldWithReason, do not return the id of the newly created stream. Returning the id of the stream upon creation could result in better integration with other protocols and a better UX, where the user immediately knows the id of his stream once it is created.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Update BoringBatchable to latest version",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "The difference between BoringBatchable in Llama Pay V2 and the main Boring Solidity repo is this PR https://github.com/boringcrypto/BoringSolidity/pull/16/files.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Add tests for weird ERC20 tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "The weird-erc20 repo has many sample contracts that mimic unusual ERC20 token behavior. Consider writing tests to check the compatibility of LlamaPay V2 with all of these contracts.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Sanitisation to avoid false event emission",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "function addPayerWhitelist(address _toAdd) external onlyOwner { require(payerWhitelists[_toAdd] == 0, \"ALREADY_WHITELISTED\"); payerWhitelists[_toAdd] = 1; emit AddPayerWhitelist(_toAdd); } function removePayerWhitelist(address _toRemove) external onlyOwner { require(payerWhitelists[_toAdd] == 1, \"NOT_WHITELISTED\"); payerWhitelists[_toRemove] = 0; emit RemovePayerWhitelist(_toRemove); }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. tokenURI() should revert for non-existent tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "LlamaPayV2Payer.sol#L135",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Missing events for critical operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Ideally, the following critical operations should trigger events: cancelDebt repayAllDebt repayDebt updateStream",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Lack of zero check on functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "For e.x., function addPayerWhitelist(address _toAdd) external onlyOwner { payerWhitelists[_toAdd] = 1; emit AddPayerWhitelist(_toAdd); } Similarly following function doesn't check for valid input address. addPayerWhitelist removePayerWhitelist addRedirectStream addStreamWhitelist removeStreamWhitelist",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. onlyOwnerAndWhitelisted should be renamed onlyOwnerOrWhitelisted",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "LlamaPayV2Payer.sol#L129",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. unchecked has no effect",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "LlamaPayV2Payer.sol#L454",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Use consistent decimals format in functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "- /// @param _amount amount to repay (20 decimals) + /// @param _amount amount to repay (native token decimals) function repayDebt(uint256 _id, uint256 _amount) external { if ( msg.sender != owner && payerWhitelists[msg.sender] != 1 && msg.sender != ownerOf(_id) ) revert NOT_OWNER_OR_WHITELISTED(); address token = streams[_id].token; + /// convert _amount into 20 decimals format + _amount = _amount * tokens[token].divisor; /// Update token to update balances _updateToken(token); /// Reverts if debt cannot be paid tokens[token].balance -= _amount; /// Reverts if paying too much debt debts[_id] -= _amount; /// Add to redeemable to payee redeemables[_id] += _amount; }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Use function to reduce duplicacy of code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "if ( msg.sender != nftOwner && msg.sender != owner && streamWhitelists[_id][msg.sender] != 1 ) revert NOT_OWNER_OR_WHITELISTED(); Following code snippet can be converted into a function. function ownerOrNftOwnerOrWhitelisted(uint _id, address _nftOwner) internal { if ( msg.sender != nftOwner && msg.sender != owner && streamWhitelists[_id][msg.sender] != 1 ) revert NOT_OWNER_OR_WHITELISTED(); } Applicable to following functions: withdraw withdrawAll withdrawWithRedirect withdrawAllWithRedirect",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Redirect recipient cannot receive funds directly",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "addRedirectStream() and removeRedirectStream() allow the receiver of the stream's tokens to sent to a different address with withdrawWithRedirect() or withdrawAllWithRedirect(). withdrawWithRedirect() and withdrawAllWithRedirect() have the same access controls as other withdraw functions, meaning only the NFT owner, the contract owner, or a stream whitelist address can trigger the transfer of funds to the redirect address. This means the redirect address does not have control over these funds but is instead relying on someone else to deliver the funds. This is a less than ideal experience for the redirect receiver, unless the intent of this feature is that the redirect address and NFT address should have the same person (or entity) owning the two addresses. If that is a hidden intent when using the redirect address, it should be clearly documented.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "strean -> stream redeeemable -> redeemable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Stream owner should be able to call updateStream()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "description": "LlamaPayV2Payer.sol#L478",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. createPool() always reverts",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "LLamalendFactory.createPool() sends ether to the LendingPool contract: payable(address(pool)).sendValue(msg.value); Since the LendingPool contract doesn't have a receive() function, this transfer reverts, in turn reverting createPool().",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Frontrunning borrow changes borrower's interest rate",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "The LlamaLend protocol calculates the interest rate of a loan in calculateInterest(). The rate curve is a linear 1-piece curve (unlike protocols like Aave that use a 2-part curve, with a steeper slope after a certain amount of borrowing). The interest rate for a loan is fixed, not variable like many other lending protocols where the rate depends on the total amount borrowed. To determine the fixed rate, LlamaLend uses the midpoint between the current borrowed amount of the new borrowed amount after the borrow action is complete. This calculation is in line 98. This introduces dependency on the amount borrowed at the time of the loan, or totalBorrowed. Frontrunning a borrow with another borrow can change the value of totalBorrowed.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. No support for cryptopunks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "Cryptopunks are at the core of the NFT ecosystem. As one of the first NFTs, it embodies the culture of NFT marketplaces. But cryptopunks does not adhere to the ERC721 standard, that limits the contract ability to accept cryptopunks as collateral.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. baseURI can be made a modifiable state variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "LendingPool.tokenURI() uses this baseURI: string private constant baseURI = \"https://nft.llamalend.com/nft2/\"; This is a constant variable and if access to https://nft.llamalend.com/nft2/ is lost, tokenURI() will start returning an inaccessible URI.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Consider removing LlamaLendFactory.receive()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "There is no need to send ether to LlamaLendFactory contract explicitly, so receive() can be removed, but even if someone sends ETH by mistake to the contract address, any one can extract them by passing empty data to repay.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. calculateInterest() does not account for pending interest payments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "When a pool has an outstanding borrowed amount, there is a corresponding amount of interest that is expected to be paid in the future. When the interest is calculated for new loans, the total value of the pool is calculated as the current pool balance plus the amount of value borrowed, which is the denominator in the calculation of variableRate. This total value does not consider the pending interest payments that are due. The result is that the total pool balance is slightly underestimated. While the existing approach of ignoring future interest payments until they are paid may have some benefit, it creates a discontinuity where the total assets held by the pool before and after a user calls repay() results in an immediate increase in pool assets.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Risk of bad debt",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "The README in the LlamaLend repository has this line in the \"Risks for LPs\" section You are selling put options on NFTs, if NFT price drops >66% before some loan expires, user will likely not repay and you'll get the NFT at a loss. Lending protocols like Aave and Compound have liquidation policies that limit the amount of bad debt that can accumulate in the protocol. This is no such protection in LlamaLend, so liquidation is only possible after loan.deadline regardless of how much bad debt accumulates. The LlamaLend README suggest a maxLoanLength value of 2 weeks will be used, but this is not hardcoded into the contracts, meaning that a longer deadline could increase the risk of bad debt and loss of value for the lender.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Oracle data replay attack",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "There is no requirement in checkOracle() that only the latest oracle data can be used. Instead, there is a deadline and any oracle data in the timeframe allowed by deadline is accepted. A user can look at the data from the last 20 minutes and choose the oracle data with a price that is most beneficial to them. This lets users \"turn back to clock\" if they don't like the latest data that the oracle is returning. This means that the oracle must be sure not to return a zero value or underestimated value for the NFT floor price in any edge case scenario, such as before the NFT floor price data is available. For comparison, when Chainlink oracle data is used, it is normally recommended to use only the latest round of oracle data, which removes the ability for a user to choose which datapoint among recent data to use.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. NFT can get locked in contract if from is a smart contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "User will receive the collateral NFT when repay() is called. However, if from is a contract address that does not support ERC721, the collateral NFT can be frozen in the contract. As per EIP-721: \"A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\" function _repay(Loan calldata loan, address from) internal returns (uint256) { ... IERC721(loan.nftContract).transferFrom(address(this), from, loan.nft); ... }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use custom errors",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "Custom errors are more gas efficient than error strings.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Variables are auto-initialized to 0",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "LendingPool.sol#L277-L279 creates an else clause to assign 0 to a return value which is already 0: } else { lateFees = 0; }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Extra event is emitted by _burnWithoutBalanceChanges()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "In a normal _burn() function, only a Transfer event is emitted. _burnWithoutBalanceChanges() emits 2 events: Transfer and Approval. The reason being it calls _approve() to clear approval, but _burn() function just deletes _tokenApprovals mapping.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "Because lastUpdateDailyBorrows is only modified by setting the variable equal to block.timestamp, block.timestamp - lastUpdateDailyBorrows can never underflow. This line and this line can be unchecked. The same logic applies to loan.startTime so this line can be unchecked.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. factory can be marked as immutable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "Since there is no function in the contract that updates the factory variable address, it can be marked as immutable.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Foundry and hardhat tests not working",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "Hardhat and Foundry tests are not working as they refer to non-existent contracts and variables, or call functions with different number of arguments.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. _burnWithoutBalanceChanges() shadows owner",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "The second argument in _burnWithoutBalanceChanges(tokenId, owner) shadows the global variable owner.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Consider allowing anyone to repay any loan",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "LendingPool.sol#L203, LendingPool.sol#L169",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Update OpenZeppelin dependencies",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "The package.json file shows a dependency of openzeppelin/contracts v4.2.0 and openzeppelin/contracts-upgradeable v4.8.0-rc1. All dependencies should be updated to the latest version available.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Flashloans are free",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "The interest due on a loan is calculated in _repay() and infoToRepayLoan(). The interest due for a flashloan is zero, meaning there is no fee for this borrowing operation. Whether this is intentional is unclear.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Interest rate \"renegotiation\" after a repayment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "The interest due on a loan is calculated in _repay() and infoToRepayLoan(). The interest due for a flashloan is zero, meaning there is no fee for this borrowing operation. Whether this is intentional is unclear.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Inaccurate comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "The word overflow in this comment that reads \"overflow checks implictly check that amount is enough\" should be changed underflow.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Align _burnWithoutBalanceChanges() with _burn()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "Although it does not change the end result, the following change in _burnWithoutBalanceChanges() can be made to use the same approach as _burn() - _approve(address(0), tokenId); + delete _tokenApprovals[tokenId];",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Missing events for critical operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Ideally, the following critical operations should trigger events: withdraw() setMaxDailyBorrows() setOracle() emergencyShutdown() doEffectiveAltruism()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Revert operation performed without proper error message",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "description": "For ex: In function borrow() it checks that current interest rate should be less than maximumInterestRate, but it does not revert with error message, which can be confusing to use, as error message helps to understand the reason why transaction failed. function borrow() { ... require(interest",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Harvesting vault can be front-run for profit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "Calling harvestRewards() will collect and distribute rewards. A bad actor can deposit tokens into the ovToken before the harvest and withdraw from ovToken right after. The sharesToReserves value will instantaneously increase and the attacker will be able to withdraw more tokens than deposited with reduced incentives for users to invest in the protocol in the future.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. _handleGmxRewards() returned values can lead to wrong accounting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "The function _handleGmxRewards() calculates GMX rewards based on balance changes and claimable rewards from GLP without considering if the claimed tokens are staked. When staking rewards, the code doesn't set to zero esGmxFromGlp. This is inconsistent with esGmxFromGmx computed using a balance change esGmxFromGlp and will be zero if rewards get staked. OrigamiGmxEarnAccount.sol#L396-L424",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Use glpRewardRouter for fetching glp trackers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "Currently, both routers point to the same trackers, but this could change. Deployed glpRewardRouter, for GMX trackers aren't set, points to address 0. The same could happen for gmxRewardRouter, GLP trackers could point to address 0.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. No Chainlink staleness check in oraclePrice()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "The Chainlink latestRoundData() function returns price data along with the roundId and timestamp of the data. If the data is stale, it should be discarded. Otherwise the protocol will trust outdated data that could lead to a loss of value from using an inaccurate exchange rate. It is recommended to check the roundId and timestamp values that the oracle returns, as shown in other security report findings here and here.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Variables could be immutables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "These variables can be declared immutable: /// @notice $GMX IERC20Upgradeable public gmxToken; /// @notice $esGMX - escrowed GMX IERC20Upgradeable public esGmxToken; /// @notice $wrappedNative - wrapped ETH/AVAX IERC20Upgradeable public wrappedNativeToken; These three variables won't change. The contract constructor can set them appropriately.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Initialize variable only if needed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "Variable esGmxReinvested is initialized before the if statement but it's only used inside the if block.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Reuse local variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "Variable fromToken can be reused instead of initializing the new variable tokenIn. The same applies to variable tokenOut. Local variable reserveAmount can be dropped from here and here if inline is used like this: underlyingQuoteData.underlyingExitQuoteData.investmentTokenAmount = _redeemReservesFromShares",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use msg.sender not owner()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "It is cheaper to call msg.sender instead of ownable() when they both return the same value. If this change is made in the constructor of MintableToken, the range of gas used on the deployment of MintableToken is reduced from the original range of 2296764-2296884 to 2296354-2296474, saving roughly 400 gas.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Incorrect comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "File OrigamiGmxInvestment has a comment with an incorrect file name.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Oracles price can be exploited",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "TokenPrices.sol#L74: this price oracle can be exploited with a single block sandwich attack. TokenPrices.sol#L85: this price oracle can be exploited via a multi-block attack by block producers. More info.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Update comment to NatSpec format",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "In file OrigamiGmxManager variables primaryEarnAccount and secondaryEarnAccount could be in NatSpec format. At least two comments (1, 2) are missing the @notice NatSpec tag. Finally, the comment on reservesToShares() is identical to the comment on sharesToReserves(), which is incorrect. The comment for reservesToShares() should be reversed to read \"How many shares given a number of reserve tokens\".",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Verify fees and rewards addresses",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "Setter functions in OrigamiGmxManager for feeCollector and rewards aggregators doesn't verify input for the default 0 value. There are no checks to prevent an address of 0 when the fees and rewards are distributed.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Remove removeReserves(uint256 amount)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "The function enables operators to take all reserveToken which can after be redeemed for other tokens depending on the OrigamiInvestment implementation. Even recoverToken(address _token, address _to, uint256 _amount) function, which is limited to only the owner, verifies the owner cannot drain the protocol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Trader Joe AMM is moving liquidity to a new AMM design",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "Trader Joe is used as a price oracle on TokenPrices.sol#L74. Trader Joe announced a new AMM design with breaking ABI changes. The design will allow anyone, not just Trader Joe, to create new trading pools, so liquidity is expected to move to the new AMM. announcement doc",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Incorrect NatSpec",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "On Operators.sol#L19 @dev NatSpec specifies this __Operators_init() initializes the owner, but it's not initializing the owner.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. addToReserveAmount could be a percentage value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "In _compoundOvGmxRewards() and _compoundOvGlpRewards(), the number of tokens to add to the reserve could be calculated using the returned value from investWithToken() and a percentage. This change would improve the precision of tokens added to the reserve, making it easier to send 100% of the rewards after slippage to the reserve.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Replace deprecated dependency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "draft-ERC20Permit.sol is the old file in @openzeppelin/contracts which has been replaced with ERC20Permit.sol. Remove the import of draft-ERC20Permit.sol and instead import ERC20Permit.sol. A related simplification is the ERC20.sol dependency can be removed from MintableToken because it is already imported through ERC20Permit.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Unusual Operator.sol implementation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "The Operator.sol contract is implemented in the same pattern as contracts from openzeppelin-contracts-upgradeable. This includes inheriting Initializeable and having an init function. But unlike other OZ upgradeable contracts, the init functions in Operator.sol don't do anything. There is no difference in the contract if it is initialize or not. A side effect of how this contract is used by other contracts is that every contract that inherits Operator.sol will have its own list of operators. If the intent is to manage only a single list of operators that have access to several different contracts, then consider deploying Operator.sol on its own, rather than as a dependency, and integrate it with the other contracts accordingly.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Reconsider using DEFAULT_ADMIN_ROLE",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "OpenZeppelin's documentation for DEFAULT_ADMIN_ROLE warns that the role is effectively a superuser. If the only changing of roles is through addMinter() and revokeRole(), using DEFAULT_ADMIN_ROLE and importing AccessControl may be overkill. It could be simpler to maintain a mapping of addresses that have this access instead of inheriting the library. Related to this, addMinter() and removeMinter() have duplicate modifiers. In the existing code, the caller must be the owner because of the modifier in MintableToken and the caller must be the adminRole because of the modifier in AccessControl. Consider removing the onlyOwner modifier to save gas.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Consider zero for minAmount",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "glpRewardRouter.mintAndStakeGlp() has two minAmount arguments. Only one of these is really necessary. Consider removing the other and replacing it with a zero minAmount depending on the standard use case for the mintAndStakeGlp() function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Broken link",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "TokenPrices.sol links to https://docs.uniswap.org/sdk/guides/fetching-prices which returns Page Not Found. Consider linking to the archived page https://web.archive.org/web/20210918154903/https://docs.uniswap.org/sdk/guides/fetching-prices.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Typo",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "description": "adggregator -> aggregator",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Underflow in int256 -> uint256 conversion",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "In GTranche.sol, pnlDistribution() and _pnlDistribution() calculate the new _trancheBalances in int256 values before casting them to uint256 when storing in the return variables. This final casting will cause an underflow if the int256 value _trancheBalances is negative. For example: Assume a scenario where the Junior Tranche is permitted 50x leverage, so the Senior Tranche has 5000 wei and the Junior Tranche has 100 wei (root causes include: no minimum deposit in the tranche, no limit on the leverage allowed, no limit on the fixed yield paid to the Senior Tranche) If the PnL distribution is not done in a long time, it is possible that the seniorProfit owed to the Senior Tranche will be greater than 100 wei. This needs to be paid to the Senior Tranche even if the profit of the tranche is zero (if lastTotal  _trancheBalances[1]. This might be possible in a tranche setup where nearly all the deposits are in the Junior Tranche so the utilization ratio is nearly zero, but an accounting error causes the losses to be greater than the total tranche assets. This scenario seems unlikely but still may be worth protecting against.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. sellAllRewards() reverts with non-zero numberOfRewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "The swapExactTokensForTokens() function in Uniswap V2 Router has a safeTransferFrom() call. The address calling the Uniswap V2 router must approve the tokens for the Router before calling this function, otherwise the function will revert. The ConvexStrategy fails to approve additional reward tokens before calling Uniswap V2.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. wethAmount in rewards calculations should be balanceOf",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "When _sellRewards() calculates the rewards that can be reinvested into 3CRV, it starts calculating with a wethAmount of zero. However, the minimum amount for converting CRV rewards or CVX rewards to ETH is 1E18 of CRV or CVX, while the minimum amount for converting ETH to 3CRV is 1E16 ETH. Assuming the current prices of $1200 WETH, $0.5 CRV, and $3.50 CVX, it is possible for a scenario where $11 worth of CRV and CVX is converted into WETH, but because the 1E16 threshold for converting WETH to 3CRV is $12, the WETH will not be converted into 3CRV. If this case happens many times, substantial WETH could accumulate in the strategy without getting reinvested to earn more yield.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Tranche deposit/withdrawal denial of service",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "The current code is written in a way that assumes the utilisation ratio remains below the utilisationThreshold unless a deposit or withdrawal will move it above the threshold. In fact, the utilisation ratio can achieve a value greater than utilisationThreshold in a couple of ways: The owner can set utilisationThreshold to any value with setUtilizationThreshold(). If the threshold is set to a value less than the current utilisation ratio, it can break assumptions about how the protocol should work and prevent tranche deposits or withdrawals. Losses for the Junior Tranche may result in a scenario where the utilisation ratio exceeds the utilisationThreshold. Note that the Junior tranche can experience a loss even when distributeProfit() is called because the yield paid to the Senior Tranche depositors may exceed the profit earned. If the utilisation ratio exceeds the utilisationThreshold, a GTranche deposit() or withdraw() that attempts to move the utilisation ratio in the correct direction may revert if it does not bring the ratio below utilisationThreshold. This behaviour breaks an assumption in the protocol documentation that such actions should always be allowed.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Unreliable Senior Tranche yield",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "PnLFixedRate.sol does not account for seniorProfit in two cases: In distributeLoss() when the loss is greater than or equal to the value of the Junior Tranche and could cause losses for the Senior Tranche In distributeProfit() when the utilisation ratio is greater than utilisationThreshold",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Timing mismatch between time-gated actions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "_calculateLockedProfit() is designed to slowly release profits to the GVault depositors. If the releaseTime is surpassed, which is 24 hours, it returns zero, which means no profit is locked. The lockedProfit value is updated when report() in GVault is called by a strategy's runHarvest(). ConvexStrategy's canHarvest(), which indicates when a keeper can call runHarvest(), has a constant MIN_REPORT_DELAY value of 48 hours. This means that if MIN_REPORT_DELAY is the determining factor for when a harvest happens, _calculateLockedProfit() will return zero for roughly half of that minimum time period. During the time that _calculateLockedProfit() returns zero, the profit calculation in PnLFixedRate of totalValue - lastTotal will return zero. This will causes the Senior Tranche to take value from the Junior Tranche to pay the fixed yield of the Senior Tranche. An example of how this could be leveraged to cause a loss for Junior Tranche holders: Depositor deposits 3CRV into the GVault The GVault does not move 3CRV to the strategy until report() is called by a strategy, so the assets may not maximize their yield for some time Depositor deposits their GVault ERC4626 tokens into the Senior Tranche and soon withdraws. The deposit and withdrawal may both be done in a short period (say, 24 hours) while _calculateLockedProfit() is returning zero. This means before report() will not have been called to deposit the loose 3CRV in the GVault to maximize yield, yet the depositor claims their fixed yield from the Senior Tranche at the cost of Junior Tranche depositors, who don't reap the full benefits of the 3CRV deposit into the GVault. If the above actions are performed frequently with large amounts of capital, say twice a week, the Junior Tranche may be less appealing for depositors. This is because the Junior Tranche is willing to pay the Senior Tranche the borrowing cost for leverage, but this cost makes more sense if the Junior Tranche is able to use the 3CRV in the strategy and not when it is sitting idle in the GVault. This scenario would get worse if the tranche had a large utilization ratio, say 10x, because the fee paid to the Senior Tranche would be larger. The flip side of this is that Junior Tranche depositors would be incentivized to withdraw their deposits during the time when _calculateLockedProfit() returns zero for the same reason.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Whale invest() and divest() denial of service",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "A whale may deposit an extremely large amount of 3CRV into GVault. When the GVault provides this 3CRV to ConvexStrategy to invest, the invest() function makes sure that the liquidity added to the metapool is within proper slippage tolerance. If the Curve pool is imbalanced sufficiently by the added liquidity, it may not return sufficient value and cause invest() to revert due to the slippage exceeding the slippage tolerance. This denial of service would not cost the whale much to sustain the DoS because they could deposit the GVault tokens into the Senior Tranche (at least until the utilization ratio is met) and receive their fixed yield, even though the Junior Tranche is not receiving its yield because the strategy's harvesting mechanism is locked up. In theory this could lead to bankrupting the Junior Tranche if carried out for long enough because the whale's deposit can't be deposited into the metapool to maximize rewards, like the \"leach attack\" described in a separate finding. divest() has a similar slippage check that may also revert under some conditions. Since users cannot control when divest happens, the whale would need to imbalance the pool outside of Gro. This DoS is likely far more costly than the invest() DoS vector because imbalancing the Curve pool would most likely create and arbitrage opportunity.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Strategy migration should remove old approvals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "setPool() in ConvexStrategy.sol gives a new metaPool infinite approval. But when this happens, the old metapool (if one was previously set) does not have its infinite approval revoked. If the old metapool had a security issue, the inability to revoke the prior approval could be problematic and would require emergency mode activation which would not be required if the approval could be revoked. The same process should take place to remove the BOOSTER approval of the old LP token.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Inconsistent ERC20 imports",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "One example showing the mixup between the OpenZeppelin and solmate ERC20 libraries is in IGVault and GVault. IGVault imports IERC20 from OpenZeppelin while GVault imports ERC20 from solmate. The solmate ERC20 library has EIP-2612 support while OpenZeppelin does not include such logic in the default ERC20 file and instead packages it in the file draft-ERC20Permit.sol. The way the code is currently written may be confusing for protocols integrating with Gro Protocol because The GVault ERC4626 token will support EIP-2612 but the GToken (and therefore the JuniorTranche and SeniorTranche) will not. Because the tranche is intended to be a wrapper for the GVault ERC4626, which does support permit(), this is not ideal because the tranche wrapper does not support permit() like the GVault ERC4626. The below slither commands can be used to demonstrate the difference in EIP2612 support. slither-check-erc --erc ERC2612 --solc-remaps \"@openzeppelin/=lib/openzeppelin-contracts/ @chainlink/=lib/chainlink-brownie-contracts/ ds-test/=lib/forge-std/lib/ds-test/src/\" ./src/tokens/GToken.sol GToken slither-check-erc --erc ERC2612 --solc-remaps \"@openzeppelin/=lib/openzeppelin-contracts/ @chainlink/=lib/chainlink-brownie-contracts/ ds-test/=lib/forge-std/lib/ds-test/src/\" ./src/GVault.sol GVault",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Similar functions have different logic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "executeStopLoss() includes the line if (strategy == address(0)) continue; which is not in canExecuteStopLossPrimer(). Likewise, canExecuteStopLossPrimer() includes the line if (strategyCheck[strategy].primerTimestamp == 0) continue; which is not in executeStopLoss(). The two functions should share logic. Currently, the lack of a zero check for strategyCheck[strategy].primerTimestamp in executeStopLoss() means a rogue keeper could execute a stop loss before primerTimestamp has been set to a non-zero value.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. ConvexStrategy owner can sweep tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "Many DeFi protocols attempt to remain immutable to enable the user to maintain control over their assets at all times. While the underlying asset token is prevented from owner sweeping, the rewards returned by the Curve metapool are impacted as are the metapool LP tokens. This could lead to loss of user funds if the owner count is compromised or acts maliciously. In order to increase trust in the protocol, the owner should be a sufficiently distributed multisig to allow users to trust it.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Inconsistent minimum reward amount",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "_claimableRewards() should compare the WETH value of rewards to MIN_WETH_SELL_AMOUNT and not to , otherwise _claimableRewards() will not return a value if the amount of rewards has a value of less than 1 ETH, which is quite a large requirement for rewards values to be included in the calculations in rewards(). The existing strategy code will underestimate the rewards returned by _estimatedTotalAssets() when the value of _claimableRewards() is between 1E16 WETH and 1E18 WETH which impacts the PnL calculations.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Inconsistent metapool fee inclusion",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "The Curve docs describe calc_token_amount(), which is used in divest(), with the following: This calculation accounts for slippage, but not fees. It should be used as a basis for determining expected amounts when calling add_liquidity or remove_liquidity_imbalance, but should not be considered to be precise! This means that in invest(), the slippage calculation compares _credit, the initial 3CRV token amount, with amount * ratio, which is the 3CRV value after slippage and fees. In contrast, divest() compares _debt, the initial 3CRV token amount, with meta_amount * ratio, which is the 3CRV value after slippage but without fees.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Potentially incorrect branching logic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "This line of realisePnl() is unreachable because if loss > _excessDebt evaluates to true, to flow would have entered this if statement instead. The duplicate line of logic should be removed or changed. The comment of here for safety, but should really never be the case before the line of code that is duplicated and never reached indicates some of the nuance of the branching may not be fully understood.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. setStrategies() doesn't set strategyCheck values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "setStrategies() does not allow setting values in strategyCheck, which is in contrast to addStrategy(). This could impact the use case where setStrategies() is useful. For example, if strategyCheck values are not set, the strategy will never return true in functions like canEndStopLoss().",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Weak oracle result staleness check in staleCheck()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "staleCheck() only checks that the Chainlink price data is under 24 hours old. The staleness check does not consider whether the roundId data may be outdated. It is recommended to do both, as shown in other security report findings here and here. Specifically, the DAI/USD oracle updates more regularly than every 24 hours. Considering that the Gro protocol has protections in place for stablecoins losing their peg, improving the Chainlink price staleness check is a crucial consideration.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. No minDeposit in GTranche",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "GVault sets a minDeposit value to prevent very small 1 wei deposits. GTranche has no comparable minimum value. When combined with the implementation of utilization() adding 1 wei to the denominator, the lack of a minDeposit is problematic in the following scenario: The utilisationThreshold is set to 3E4, implying there can be 3 tokens deposit into the Senior Tranche for every token deposited into the Junior Tranche 1 wei is deposited into the Junior Tranche 3 wei is deposited into the Senior Tranche, which should be the maximum amount permitted to maintain the 3-to-1 ratio With the current tranche holdings, utilization() returns a value of (3 * 1E4) / (1+1) = 15000, which is half of the utilisationThreshold limit of 3E4 An additional 3 wei can be deposited into the Senior Tranche. Now utilization() returns (6 * 1E4) / (1+1) = 30000, but the ratio of Senior Tranche deposits to Junior Tranche deposits is 6-to-1, not the originally intended 3-to-1 Beyond the risk of underinsured Senior Tranche deposits, another side effect of the lack of minDeposit is the possibility of an inflation attack.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Volatile token price causes higher vault fees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "_calcFees() is called only once in GVault, from report(). _calcFees() is a bit of a misnomer because the function also takes those fees and sends them to the feeCollector address specified by the owner using setFeeCollector() while returning the gains amount minus fees. The gains are defined as the difference between all the strategy's assets (loose assets, LP tokens, and rewards) and the strategy's debt, which is a value stored in strategies[strategyAddress].totalDebt in the GVault. A key part of this is that when a strategy reports a loss, the totalDebt of the strategy is reduced to account for the loss, so it is as though the strategy received fewer assets to begin with. The combination of how fees are taken from gains and the goal post for how gains are calculated getting moved on every loss creates a problematic combination. Consider the following series of events: Value of Strategy is $1000 Strategy loses $20 and report() is triggered Strategy gains $20 and report() is triggered (pays vault fee on $20 gains) Strategy loses $20 and report() is triggered Strategy gains $20 and report() is triggered (pays vault fee on $20 gains) The strategy has paid the vault fee twice even though the value in the strategy hasn't changed. It is only the volatility in the strategy's assets that caused the fees to be applied. This penalizes depositors for market volatility instead of penalizing them for withdrawing, which is how the Gro protocol is documented to work today. Note that this specific strategy is built on 3CRV and the Frax Curve metapool, so the value of the LP tokens should only increase and not be subject to such volatility. By deducting fees at the time of profit, there is less value in the vault to compound and grow, which slightly reduces the appeal of the strategy.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. High default slippage tolerance",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "The default value of PERCENTAGE_DECIMAL_FACTOR if 1E4 while baseSlippage is 50. This means the default tolerance is (10000 - 50) / 10000 = 9950 / 10000 = 99.5%, allowing for 0.5% slippage, in invest() and divest(). When the Frax metapool was examined at the time of this review, the Curve Finance frontend estimated a 0.03% slippage if withdrawing 1E8 LP tokens, which was over 20% of the total supply of the metapool. Similarly, when estimating the slippage for a deposit of 1E8 CRV tokens, which would increase the existing balance of CRV in the metapool by over 50%, the frontend estimated a 0.06% slippage. Given the size of the slippage with such large deposits or withdrawals, and considering that the default slippage tolerance on the Curve frontend for this Frax metapool is 0.1%, the existing combination of PERCENTAGE_DECIMAL_FACTOR and baseSlippage provides too large of a slippage tolerance.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Use prefix in loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "There are instances of this throughout the contracts, with examples of this optimization opportunity found in GStrategyGuard.sol, GTranche.sol, and GRouter.sol.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Unnecessary zero initializations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "There are instances of this throughout the contracts, with examples of this optimization opportunity found in GTranche.sol, GRouter.sol, StrategyQueue.sol, and ConvexStrategy.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Use simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "The withdraw() function in ConvexStrategy provides one example of this, but there are other instances in the contracts: if (withdrawnAssets  withdrawnAssets - _amount) { loss -= withdrawnAssets - _amount; } else { loss = 0; } } By switching around the if/else clauses, we can replace the compound operator with a simple one if (withdrawnAssets > _amount) { if (loss > withdrawnAssets - _amount) { loss -= withdrawnAssets - _amount; } else { loss = 0; } } else { loss += _amount - withdrawnAssets; }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Remove redundant check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "mint() in GVault checks if assets is zero and then checks if assets is less than minDeposit. The first check is redundant because if assets is zero, then assets",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "Require statements are found in the JuniorTranche, SeniorTranche, GToken, and GVault contracts (examples include 1, 2, 3, 4). Using this new solidity feature can provide gas savings on revert conditions.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Declare variables immutable when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "The IsGTrancheSet boolean is set only once in GMigration.sol and can be immutable.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "One example where unchecked can be applied: - loss = lastTotal - totalValue; + unchecked { loss = lastTotal - totalValue; } Similar savings can be found throughout the contracts including here, here, and here.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Unusual minDeposit choice",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "This line of GVault.sol may have a typo if the intent is to have a minimum deposit of at least one dollar (because the vault is designed for stablecoins).",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Fees may be sent to address(0)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "The GVault default is to have vaultFee and feeCollector remain unset, which keeps them at the default values of 0 and address(0) respectively. It is possible for vaultFee to be set to a non-zero value while feeCollector remains at zero, resulting in fees getting sent to address(0).",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Missing _minAmount check in redeem",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "deposit() and mint() verify the deposit amount is greater than minDeposit while withdraw() checks that the asset amount is greater than the user-specified _minAmount before transferring tokens. redeem() does have a comparable minimum value check before assets are transferred.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. _owner argument shadows Ownable state variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "withdraw() in GVault.sol has a _owner argument that shadows a state variable with the same name in OpenZeppelin's Ownable library.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Junior tranche lacks immediate withdrawal guarantees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "In order to deposit in the Senior Tranche, there must be sufficient value in the Junior Tranche to protect Senior Tranche deposits. This means that if the Junior Tranche protects the Senior Tranche 1-to-1 and there is 100% utilization, no Junior Tranche funds can be withdraw. In the event that all depositors to the Junior Tranche wish to withdraw, there could be a \"bank run\" where the first users to withdrawer receive their funds, but when the utilization ratio hits 100%, no Junior Tranche funds can be withdrawn because they are needed to protect the funds in the Senior Tranche. This behaviour is the norm for tranche structures, but users who have not interacted with such a pool design may not clearly understand the limitations of the system. This could be problematic for users if they have a loan in a protocol like Aave that is about to be liquidated and they cannot withdraw their funds from the Junior Tranche to increase their loan collateralization ratio. A real scenario where this would be incentivized to take place is a \"leach attack\", when the fixed yield on the Senior Tranche exceeds what the underlying vault is capable of producing and the Senior Tranche depositors leach off the Junior Tranche value. If the Senior Tranche promised an absurdly high fixed yield, or if the underlying vault yield drops to a near-zero value, the Senior Tranche depositors would be more incentivized to keep their token in the Senior Tranche to receive the \"impossibly good\" yield, even though the yield the Senior Tranche is receiving is being taken from the token value of the Junior Tranche depositors (because the yield from the vault cannot cover the fixed yield amount). It is true that the tranche owner can set the fixed rate with setRate(), but there may be a delay before this happens (possibly a DAO vote), during which time value could be leached from Junior Tranche depositors and the Junior Tranche depositors would be unable to withdraw because 1. the utilization ratio does not permit it 2. the leaching causes a loss of value in the Junior Tranche which makes the utilization ratio even worse.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Change call sequence for reentrancy mitigation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "In _withdraw(), funds are transferred out of the GVault before the vaultAssets state variable is updated. According to checks-effects-interactions, the external interactions should happen last, meaning the vaultAssets variable should be updated before funds are transferred. This is what the solmate ERC4626 implementation does by calling the internal _burn() first to update the totalSupply value before transferring funds, which is the opposite of when the transfer happens relative to _mint() in mint(). The same change can be applied to redeem() and report() (1, 2).",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Undocumented assumption of private Gelato mempool",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "MEV protection mitigates the risk of a frontrun, backrun, or sandwich that can extract value from a transaction. This most often happens during swap operations. The design of Gro Protocol assumes that when a Gelato keeper executes a transaction, there will be MEV protection. The Gelato documentation does not clarify that this is a guarantee that keepers offer and whether there is still risk of an uncle bandit attack. The MEV mitigation is expected to exist based on discussions with the Gro devs, but the lack of official documentation around the mempool guarantees provided by Gelato jobs, the possibility of changes over time, and the risk of a rogue Gelato keeper are all possible concerns with this approach.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Inconsistent interface files",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "metapool is cast as ICurve3Pool here because get_virtual_price() is found in the external Curve3Pool contract and is inherited by the metapool contract. However, the same could be said about remove_liquidity_one_coin(), but metapool is cast as ICurveMeta when removing liquidity (1, 2, 3) because the Curve3Pool usage in ConvexStrategy didn't use that function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Inconsistent Uniswap array indices",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "Uniswap references the amountOut value with amounts[amounts.length - 1] with comparing that value to amountOutMin, and this approach is found once in ConvexStrategy. Another approach of hard coding an index of 1 is found elsewhere.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. _additionalRewardTokens() works in unexpected way",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "In rewards(), _additionalRewardTokens() is summed with _claimableRewards(). The latter returns the value of claimable rewards that can be received if getReward() is called as it is in sellAllRewards(). In contrast, _additionalRewardTokens() does not do this. Instead, _additionalRewardTokens() sums the current balance of award tokens in the strategy. This can result in a different value than the return value of sellAllRewards(), which is likely unexpected behaviour.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Non-ideal _sellAdditionalRewards() min reward limit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "Consider a value different from the current MIN_REWARD_SELL_AMOUNT used in _sellAdditionalRewards() because different tokens have different decimals values and different values. A more flexible choice of value would be preferable to enable flexibility with future reward tokens.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Strategy migration logic can revert",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "divestAll() is written to avoid a revert condition at all costs because it is intended to be used for the emergency scenario where reverting is not an option. divestAll() is called immediately before migratePool(). After the migration, realisePnl() is called which has has divest() calls (1, 2) which offer an opportunity for a revert to happen. This could prevent the migration from happening in some circumstances.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Theoretical casting overflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "This line of StopLossLogic casts a uint256 dy_diff to an int256 value. It is possible a very large unsigned value would be converted to a negative number.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Differing approach to keeper role",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "The keeper variable in GStrategyGuard stores a single address while a similar keepers variable in ConvexStrategy allows for multiple addresses to serve as keepers. Allowing more keepers provides more flexibility if Gelato changes their operations to have multiple addresses executing transactions, or to allow the owner address to serve as a keeper.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Duplicate strategies possible with setStrategies()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "_addStrategy() does not permit a strategy to be added to the strategies array if it is already in the array. But the owner could use setStrategies() to do the same.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Unnecessary ERC4626 casting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "getYieldToken() in FixedTokensCurve returns an ERC4626 value. But GTranche needlessly casts this return value to an ERC4626 in several places (1, 2, 3, 4).",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. getSwappingPrice() doesn't make sense with single strategy and vault",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "The Gro protocol as examined only has one token that is deposited into it, as the return value of getYieldToken() shows. The current implementation of getSwappingPrice() allows any uint256 input values for function arguments i and j and always returns the input _amount which implies a 1-to-1 exchange rate between token i and token j. This return value doesn't make sense. It would make more sense to follow an implementation like getYieldToken() shows and only allow an i and j value of zero, reverting in other cases.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. No upper limit to Junior Tranche leverage or fixed yield",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "Setting an upper bound on the leverage available to a Junior Tranche, and therefore a lower bound on the protection available to Senior Tranche depositors, may be prudent to avoid blatant misuse of the Gro tranche design. Additionally consider a limit on the fixed yield amount, which could be adjusted by the protocol owner depending on market conditions. Be aware that the yield in the tranche design is dollar denominated, so if the underlying asset drops in value, there could be issues in paying the fixed yield to the Senior Tranche. We can take one example of the Junior Tranche taking 20x leverage by borrowing from the Senior Tranche, with a fixed Senior Tranche yield of 2%: 100% utilizationRatio * (20x leverage - 1x from Junior Tranche) * 2% Senior Tranche Fixed Yield = 38% borrowing cost owed to Senior Tranche Due to the amount of leverage in the Junior Tranche and the yield promised to the Senior Tranche depositors, the Junior Tranche could easily see losses if it cannot continue to deliver the 38% yield.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Multiple migration functions increase trancheBalances",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "migrateFromOldTranche() increases the tranche balances here. migrate() does so here. The two migration functions appear to serve different purposes, but a boolean protecting the two functions from both getting called does not exist. Instead, hasMigratedFromOldTranche is only found in migrateFromOldTranche().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. Unclear redistribution of vault fees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "Existing Gro protocol documentation mentions the withdrawal fees are redistributed back to the protocol. While this may not be true with the upgraded Gro protocol, if the fees are to be redistributed to the protocol, it should be done in a way that is not gameable.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Tranche tokens not compliant with ERC4626",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "To clarify, the tranche tokens do not currently implement ERC4626 but the documentation uses the word \"ERC4626 wrapper\" when describing the tranche, which could be misleading. GVault and tranche tokens import the same ERC4626 to implement basic ERC4626 support. GVault overrides many virtual functions from this import to implement them correctly according to ERC4626 specifications, but GTranche does not. The functions that should be implemented in GTranche to comply with ERC4626 include: mint() deposit() withdraw() redeem() convertToShares() convertToAssets() maxRedeem() previewRedeem() maxWithdraw() previewWithdraw() maxMint() previewMint() maxDeposit() previewDeposit()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "48. Silent returns",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "move() in StrategyQueue silently returns in three cases. This may give the owner calling moveStrategy() a false sense of confidence that the strategy was moved, when it in fact was not.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "49. Minor nitpicks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "description": "Consider naming withdrawalQueue(uint256 i) to withdrawalQueueAt(uint256 i) and withdrawalQueue() to fullWithdrawalQueue(). Consider clarifying the strategy return value is an address, not a Strategy struct. getStrategyDebt() and getStrategyAssets() return the totalDebt of a strategy and might be improved with more similar names to avoid confusion over debt vs. assets. NatSpec is incomplete for some functions, such as missing return value descriptions for beforeWithdraw()/excessDebt/_excessDebt and no NatSpec for _removeStrategy() in GVault depositIntoTrancheForCaller() is missing a comment that _token_index of 3 or greater is 3CRV Typo: adapetr -> adapter Typo: Apporve -> Approve Typo: CHIANLINK_FACTOR -> CHAINLINK_FACTOR Typo: add_liquididty -> add_liquidity Typo: strategies -> strategy's and same here Typo: enstimated -> estimated Typo: excluding and profits -> excluding profits Typo: srategy -> strategy Typo: do generate -> to generate Typo: unledrying -> underlying Typo: beneth -> beneath and here Typo: baring -> bearing Typo: extensoin -> extension Typo: their -> there Typo: underlyng -> underlying Typo: prive -> price Typo: it -> its Typo: utiliszation -> utilisation Typo: _tranchTokens -> _trancheTokens Typo: between to underlying -> between the underlying Typo: amount of price -> amount of yield token Typo: and ontermiadry -> an intermediary Typo: amount of transform (unclear what this means) Typo: setUtilizationThreshold() (note utilization with a 'z') sets the variable utilisationThreshold (note utilisation with 's') and there is a function utilization() (note utilization with a 'z') Typo: experiene -> experience Improve precision by changing ((_lockedProfit / _releaseTime) * _timeSinceLastReport) to ((_lockedProfit * _timeSinceLastReport) / _releaseTime) to match Vault.vy approach Fix this comment that references a non-existent emergencyExit() function The emergency boolean function argument is missing a NatSpec comment as is _calcFactor() in GTranche and _loss in PnL The debt variable is not used for any purpose. It may be better to simply compare debtPayment to the value of _excessDebt(msg.sender) to replace the safeMath in this line. Inaccurate NatSpec for withdraw()'s _amount (better would be \"asset quantity needed by Vault if not holding enough asset balance\") and missing NatSpec for return values Replace PnL magic numbers with constants. For example, replace 10000 with utilisationThreshold. Junior Tranche is branded as GVT token, so this comment should replace PWRD with GVT Consider a better name than \"controller\" or \"ctrl\" in GToken for the GTranche address, because the word \"controller\" does not appear anywhere in GTranche Assets in Convex are not locked and therefore are not used to vote in reward distribution. There are potential downsides to this approach and this choice should be documented somewhere in Gro's documentation. The strategy that ConvexStrategy was inspired by does lock some tokens for voting. _claimableRewards() in ConvexStrategy does not return a value if MIN_REWARD_SELL_AMOUNT is not met and this if statement is not entered Consider replacing slippage in divestAll() with the baseSlippage value used elsewhere because baseSlippage can be modified by the owner unlike slippage estimatedTotalAssets() should replace _estimatedTotalAssets(true) with _estimatedTotalAssets(false) because the rewards return value is not needed Incomplete NatSpec for factor in _calcTrancheValue() and factor elsewhere in GTranche This return is redundant, the named return values would be returned properly without this line The SafeMath OpenZeppelin import in GToken is redundant because solidity 0.8.10 is used. The contract should be updated accordingly. The Ownable import in GToken is redundant because the import of Whitelist.sol includes Ownable already _calcTokenAmount() can remove the _deposit boolean function argument because it is never used for anything useful in the function The NatSpec in CurveOracle uses the term \"yield token\" to mostly refer to 3CRV while FixedTokensCurve NatSpec uses \"yield token\" to mostly refer to GVault shares. Consider terms that more clearly differentiate the tokens. Remove unused _tranche bool function argument from _calcTrancheValue() Remove if (_factor == 0) logic from _calcTrancheValue() because this can never happen based on current contract logic lastDistribution could be uint32 instead of uint64 Consider renaming _calcFees() to _gainSubFees()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Anyone can call uniswapV3MintCallback() stealing the protocol fees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "LiquidityManagement::uniswapV3MintCallback() only checks that msg.sender == address(decodedData.pool), which any attacker can trivially fulfill by setting decodedData.pool to an address they own. The function then transfers decodedData.pool.token0() and decodedData.pool.token1() to msg.sender, the amount of which is specified by the caller.",
        "labels": [
            "yAudit",
            "Severity: Critical",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Anyone can call the PeripheryPayments sweepToken() stealing the protocol fees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "PeripheryPayments is a dependency of the LiquidityManagement contract, which is a dependency of the BunniHub contract. PeripheryPayments has a sweepToken() with no access control which allows a caller to transfer any token from the BunniHub contract to any recipient.",
        "labels": [
            "yAudit",
            "Severity: Critical",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Anyone can call the PeripheryPayments unwrapWETH9() stealing the weth stored in BunniHub",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "PeripheryPayments is a dependency of the LiquidityManagement contract, which is a dependency of the BunniHub contract. PeripheryPayments has a unwrapWETH9() with no access control which allows a caller to the contract's weth balance from the BunniHub contract to any recipient.",
        "labels": [
            "yAudit",
            "Severity: Critical",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. General complexity around ETH management including certain circumstances where ETH could be lost",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "The BunniHub contract currently only has one payable function that can receive ETH which is the receive() found in PeripheryPayments. That function requires that the sender is WETH9. In general BunniHub will not be interacting with ETH but there is functionality embedded with the Uniswap imports related to the management of ETH which adds complexity and some risk. abstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState { receive() external payable { require(msg.sender == WETH9, 'Not WETH9'); } If for some reason someone unwrapped WETH and set the recipient to the BunniHub, then the contract would no hold the ETH. This ETH could be taken by anyone via refundEth() or it could also be included used the next time anyone deposited into a WETH pool since pay() includes some logic that is designed to work with with unwrapping WETH: function pay( address token, address payer, address recipient, uint256 value ) internal { if (token == WETH9 && address(this).balance >= value) { // pay with WETH9 IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay IWETH9(WETH9).transfer(recipient, value); } else if (payer == address(this)) { ...",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Calling withdraw() forfeits uncollected LP fees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "Fees are collected and reinvested via compound(), but when withdraw() is called, fees are not collected.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Optimize the sweepTokens() loop",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "@@ -436,12 +453,16 @@ contract BunniHub is - for (uint256 i = 0; i",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Upgrade to at least solidity 0.8.4",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "Currently there is no underflow or overflow protection at the compiler level in Bunni, which means SafeMath style libraries are necessary, which are gas inefficient compared to the compiler and potentially less safe. Also see hrkrshnn's related comment.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use latest versions of unmodified libraries",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "The contracts are using Solidity 0.7.6 some library contracts (CREATE3, ERC20, and SafeTransferLib) were copied into the directory rather than being imported. However, due to these being copied into the project and also because of some modifications, they do not match the latest versions of these projects.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Consider Foundry scripting for the deployment scripts",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "Currently bash scripts are used for the deployment scripts. While they are currently relatively simple, as the project progresses this may no longer be the case.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Typo in README",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "There is a typo in the README \"perfer\".",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Consider adding npm related steps to the README",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "npm is used to manage dependencies but this information is not present in the README.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Consider removing the WETH unwrapping logic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "description": "One of the critical findings is related to WETH management. If it's not necessary it is a source of unecessary additional complexity that may lead to other future vulnerabilities.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Inaccurate rounding from maximize",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "There are two locations where mulDivDown() uses _getGlpPriceInUsdc(state, maximize) in the denominator and one place where _getGlpPriceInUsdc(state, !maximize) is in the denominator. This inconsistency indicates a bug. If a fraction is intended to be maximized (with maximize set to true), then the denominator should be reduced (with maximize set to false). If the fraction is intended to be minimized (with maximize set to false), then the denominator should be increased (with maximize set to true). This indicates that the correct value of maximize when it is used in the denominator is inverted from the value it holds in the current function. The two cases where this is not done, line 1140 and line 1146, should be fixed to align to line 1172.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Loss of precision can lead to loss of value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "The calculation of minTokenOut in _convertToToken() is done in a way where the value is reduced to 6 decimals of precision, then increased to the number of decimals needed for that specific token. This process means that all digits beyond the first 6 decimals of precision will be zeros. This effectively rounds down the value, which increases the amount of possible slippage from the value targeted by the slippageThreshold value. This could result in minor loss of value.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Possible underflow could cause revert",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "A comment in _executeVaultUserBatchStake() attempts to explain why _roundUsdcBalance will be always >= _usdcToConvert, but the logic does not hold up. Take the following example scenario. Starting values: usdcAmountToConvert = 1 _roundUsdcBalance = 2 minUsdcConversionAmount = 4 Logical steps After line 388: _usdcToConvert = 1 After line 397: _usdcToConvert = 4 _roundUsdcBalance - _usdcToConvert will underflow on line 399 because _roundUsdcBalance = 2 while _usdcToConvert = 4 The same logic is found in DnGmxBatchingManagerGlp.sol.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Cannot undo infinite approval",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "grantAllowances() in the batching managers gives an infinite approval of sGLP to dnGmxJuniorVault, but there is no way to undo this approval. It may be useful to add a function argument to grantAllowances() to allow a custom approval value to be set, including an approval of zero. While the batching managers are implemented behind proxies, in the event that the approval needs to be removed, response time will likely be important so it is preferable to have failsafes in place before they are needed. Because dnGmxJuniorVault is implemented behind a proxy, the code at that address today may differ from the code at that address in the future, making safety measures more important.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. abs() reverts for type(int256).min",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "The abs() implementation in SignedFixedPointMathLib is not from OpenZeppelin's SignedMath. OpenZeppelin's code has a comment indicating unchecked must be used to support the argument value of type(int256).min. The current abs() implementation reverts on this value. Because mulDivDown() relies on this abs() implementation, it too would revert in the case of x == type(int256).min.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Missing assert risks casting overflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "_calculateSwapLoss() contains two casting operations where a value is negated. In the second case, it is clear that the negation will make tokenAmount positive because tokenAmount is less than zero in that code branch. But in the first case, it is not clear that the negation will make otherTokenAmount positive rather than negative. _calculateSwapLoss() is called with values returned from QuoterLib.quoteCombinedSwap(). quoteCombinedSwap() contains an assert that validates ethAmountInEthSwap and usdcAmountInEthSwap have opposite signs. But there is no similar check to confirm btcAmountInBtcSwap and usdcAmountInBtcSwap have opposite signs. This means the _calculateSwapLoss() call with BTC values may have a chance of a casting overflow because there is no assertion to guarantee avoidance of this case.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Combine zero checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "In batching manager, when executeBatch() is called it checks if the function argument is zero and then later checks if a value derived from the argument is zero. The first check can be removed, because if the function argument is zero it will be caught in the second check. The same logic is in DnGmxBatchingManagerGlp.sol.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "There is at least one example where unchecked can be applied, because the line before the subtraction prevents an underflow: - userDeposit.unclaimedShares = userUnclaimedShares - amount.toUint128(); + unchecked { userDeposit.unclaimedShares = userUnclaimedShares - amount.toUint128(); } The same modification could be made to DnGmxBatchingManagerGlp.sol.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Use cached value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "userDeposit.usdcBalance is cached in userUsdcBalance in depositUsdc(). This cached value can be used instead of userDeposit.usdcBalance on line 225. This optimization is already used later in the same contract. The same edit can be made in DnGmxBatchingManagerGlp.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Remove unused functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "simulateSwap() with 4 function arguments is not used anywhere and can safely be removed from Simulate.sol to save some gas on deployment. The onlyDnGmxJuniorVault modifier is declared in DnGmxBatchingManager and DnGmxBatchingManagerGlp but is never used in Rage Trade. These modifier declarations can be removed.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Consider refactoring",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "_getMaxTokenHedgeAmount() is nearly identical to _getTokenHedgeAmount(). The only difference is in the last line of these functions. _getTokenHedgeAmount() could be replaced with _getMaxTokenHedgeAmount() * _traderOIHedgeBps / MAX_BPS.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Update and improve comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "Several improvements can be made in comments: DnGmxBatchingManagerGlp.sol now handles USDC instead of GLP. Many comments still reference GLP but should now mention USDC. For example, this comment and this comment in depositUsdc() should say USDC not sGLP. There are other comments that also need updating to reflect the switch to using USDC. slippageThresholdGmxBps in DnGmxBatchingManager is used for USDC slippage but also WETH slippage in rescueFees(). This comment only mentions USDC but should mention WETH. _getMaxTokenHedgeAmount() is nearly identical to _getTokenHedgeAmount() but the comments of the two functions are identical. The difference is that _getTokenHedgeAmount() returns a value multiplied by _traderOIHedgeBps. This difference in not reflect in the comments of the function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Efficiency improvement",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "The tokenTraderOIMax function argument for the function _checkTokenHedgeAmount() is returned from _getMaxTokenHedgeAmount(). This returned value should always be positive. This means tokenTraderOIMax.sign() == 1, so _checkTokenHedgeAmount() can be simplified with the following: function _checkTokenHedgeAmount(int256 tokenTraderOIHedge, int256 tokenTraderOIMax) internal pure returns (bool) { - if (tokenTraderOIHedge.sign() * tokenTraderOIMax.sign()  tokenTraderOIMax.abs()) return false; + if (tokenTraderOIHedge > tokenTraderOIMax) return false; return true; }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Migration requires managing slot reuse",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "In DnGmxBatchingManager.sol, the glpDepositPendingThreshold variable in the old contract version is renamed to minUsdcConversionAmount in the new contract version. This storage slot used to store an amount of GLP but now stores an amount of USDC. If the logic contract behind the proxy is upgraded before this storage slot value is changed, a well-timed attack may be able to take advantage of the incorrect value. Similarly, the deprecated variables should be set to zero before the upgrade. While roundGlpDepositPending is already set to zero, the private bypass variable is not, so setBypass() should be called before the upgrade, otherwise the variable will remain set. batchingManager in",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Use updated solmate import",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "Consider replacing the outdated reference in package.json and multiple solidity files to use the current location of the solmate library. This will help to ensure the latest bug fixes and improvements are used.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Possible mulDivDown confusion",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "Consider renaming the custom mulDivDown() implementation to indicate the first argument is a int256, not a uint256 like the solmate implementation of mulDivDown(). One place where this ambiguity may cause confusion is this line. Solidity will prevent an underflow from happening, so the solmate implementation will be used if no revert happens, but should an underflow be allowed here with unchecked to allow the custom implementation to be used?",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Unnecessary operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "This line unnecessarily casts netSlippage to uint256 when it is already of that type. This line emits an event with the constant value of address(0). Because this event is used in only this one location, there is no point in this event taking a constant value.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Change variable name",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "The variables name unhedgedGlp is used in two places in DnGmxJuniorVaultManager. Only the second case of this variable actually refers to the exact value of unhedged GLP maintained by Rage Trade, while the first case actually refers to the target amount of unhedged GLP that the protocol should rebalance to.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Missing NatSpec comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "Several variables and functions could benefit from improved NatSpec: depositCap: add the comment \"Maximum USDC that can be deposited in one round\" depositCap: add the comment \"Maximum sGLP that can be deposited in one round\" depositUsdc(), executeBatch(), claimAndRedeem(), rescueFees(), and all internal functions are missing NatSpec in DnGmxBatchingManager.sol. batchingManager variable in State struct should be marked as deprecated because batching manager integration was removed. _getBorrowValue() should have a comment to specify the return value is in USDC not USD",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Typos in comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "description": "These typos were found in comments: cooldowm -> cooldown depoists -> deposits roudn -> round accumuated -> accumulated mangager -> manager cooldowm -> cooldown depoists -> deposits roudn -> round accumuated -> accumulated flase -> false (found here, here, here, and here) glp price in usd -> glp price in usdc (found here and here) againts -> against assests -> assets retunrs -> returns",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Possible locking of pool fee funds",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Pools mechanics don't incentivize end goal",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Flashloan/Whale slippage manipulation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Single depositor in pool can steal funds from other pools",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. allPrices gas grieving causes complete loss of on-chain oracle",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Pool drain via Oracle Update Sandwich Attack",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Incorrect tolerance for price reported by Chainlink Oracle",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Frozen protocol fee when too many pools are deployed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Planned functionality incentivizes low pool liquidity",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Deposit fees even below 100% CR & withdrawal fees above 100%",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. _getG is not continuous",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. maxPriceTolerance does not work correctly",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Price updates can be sandwiched",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Chainlink oracle may return stale data",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Fee-free deposit() and withdraw() can be gamed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Mechanics increase bank run risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Oracle price lag enables 1% arbitrage opportunities",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Slippage calculations are not path independent for large trades",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Reentrancy in SingularityPool.collectFees()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. It can be profitable to split up orders",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. _getG exponentiation can overflow for large CR values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Todo comment indicates necessary change",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Denial of service edge case if onlyUseChainlink is false",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. No pool existence check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Missing zero address check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. g function discontinuity at 0.3",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Missing two-step transfer ownership pattern",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Division before multiplication",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Deposit cap is inaccurate",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Use unchecked in SingularityPool.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Replace modifiers with internal functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Payable functions can save gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Use short require strings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Using simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Using Yul iszero()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Replace bool with uint256",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Declare immutable variables internal when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Redundant function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Remove nonReentrant modifiers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Remove feeA > feeB test in getDepositFee()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Collateral ratio calculations have redundant SLOADs",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. Replace ProtocolFees state var with Slippage",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. Tight variable packing",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Use unchecked when there is no risk of overflow or underflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. Do not load calldata length in memory for loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Unnecessary named return variable assignment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "48. Combine accounting updates in swapIn and swapOut",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "49. Routers can give infinite token approval to pools",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "50. Immutable state variable which is defined as a public variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "51. Difference from Uniswap's safeTransferFrom() logic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "52. Centralization risk with admin role",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "53. baseFee value not limited",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "54. No way to remove pools",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "55. Fee-on-transfer tokens not supported",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "56. Documentation inconsistencies",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "57. Decimals value borrowed from underlying ERC20",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "58. Typo",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "59. nonReentrant modifier is specific to each pool",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "60. Pool may not be able to reach depositCap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "61. Incorrect balance accounting for fee-on-transfer and rebasing tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "62. Reduce footgun risk of deposit() and withdraw()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "63. Code does not match docs",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "64. Just-in-time LP provision can be profitable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "65. Potentially misleading description of \"no impermanent loss\"",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "66. Miscellaneous",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "description": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Incorrect ratios used for delta neutral rebalancing",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "Rage Trade relies on providing liquidity to the GMX protocol for long exposure to WETH and WBTC. The GMX Vault is where all GMX protocol underlying assets are stored. The GMX vault has a target weight for each underlying asset, but the target weight is not the same as the current weight of the asset in the vault during a specific block. The actual weights of the tokens The Rage Trade rebalancing approach uses the ideal target weight, not the actual current weight of the asset. This means the Rage trade strategy is not actually delta neutral because it assumes an ideal mix of underlying assets when holding GLP and doesn't consider the current underlying assets. To demonstrate the issue, data was taken from the Arbitrum blockchain to plot the exposure that Rage Trade has had to the underlying assets WETH and WBTC since around the time that the delta neutral strategy began receiving funds. The short exposure takes the form of WETH or WBTC borrowed from Aave. To calculate this percentage, the amount of WETH or WBTC borrowed was multiplied by the price of the asset and then divided by the total value of GLP held by the Rage trade strategy. The short exposure does a good job of targeting the 35% and 15% marks for WETH and WBTC respectively. The 35% and 15% marks are the target allocations for the GMX vault to hold of WETH and WBTC. The long exposure takes the form of GLP, which holds roughly 50% stablecoins and 50% WETH and WBTC. The data for the exposure to WETH and WBTC was taken from at stats.gmx.io during the same period as the short position exposure chart. The comparison of the short and long exposure to WETH and WBTC is shown below. As the charts demonstrate, since the deployment of Rage Trade in December 2022, the GMX vault, and therefore GLP, has consistently held more WBTC and less WETH than the GMX vault target weights. But the Rage Trade short positions do not reflect this, and instead use the target weights to determine the ideal short exposure to these assets. In its current form, Rage Trade has held a position of long WBTC and short WETH since it was deployed. Examining the asset exposure in the GMX Vault over the entire duration of GMX's history, it is more apparent how far the asset allocations can stray from the target. The second figure below focuses on the less volatile period of GMX asset allocation in 2022 to provide a closer look at how different the asset allocation is from the 35% WETH and 15% WBTC targets. Since June 2022, the GMX vault has mostly been overweight in WBTC and underweight in WETH, but sometimes it is overweight in both assets. Focusing on more \"extreme\" changes in the asset allocations of the vault, the vault held a total of 39.4% in WETH and WBTC combined on May 26 2022, but that rose to 54% on July 24 2022, less than 2 months later. If this strategy was active at this time, it would have had too large of a short position and too small of a long position. It is true that during this time the value of WETH and WBTC dropped by around 22%, so in actuality these months would have been profitable for this strategy, but a reverse scenario where the assets increased by 22% in value would have left the strategy at a loss. Even if the above scenario where the strategy is weighted in the wrong direction of market movements does not occur, another risk is if the correlation between WETH and WBTC prices change significantly. It's possible there is an implied assumption that WETH and WBTC prices are correlated, so as long as the sum of allocations WETH and WBTC in the GMX vault is roughly 50% of the GMX vault, then the long position should neutralize the short position. But if the WETH/WBTC price correlation changes while they GMX vault allocations are not near the targets, this could be problematic. The chart from CoinGecko shows this ratio over the last two years and demonstrates that it can easily change by 10% or more in a short timespan. In summary, the risk this issue highlights includes: strategy losses from when WETH and WBTC positions are overweighted towards a long position and the prices of these assets drops. The reverse can also happen, where WETH and WBTC positions are underweighted towards a long position and the prices of these assets rises. strategy losses from when WETH and WBTC weights in the GMX vault are not at the target weights and the WETH/WBTC price ratio changes in the wrong direction from how the GMX vault (and therefore the Rage Trade strategy) is weighted.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Junior vault getPriceX128() has wrong decimals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "The term X128 as used in Uniswap documentation indicates a Q128 value. This means that the value should be divided by 1",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. maxWithdraw() and maxRedeem() are inaccurate if Aave pool doesn't permit withdrawals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "EIP4626 states the following requirements for maxRedeem(): Maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call. MUST return the maximum amount of shares that could be transferred from owner through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0. If an Aave pool is paused or inactive, maxWithdraw() and maxRedeem() in the senior vault should return zero. The functions currently do not. Currently the senior vault is not compliant with the ERC4626 spec if the Aave pool is inactive or paused. maxMint() and maxDeposit() should also have a similar change.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. maxMint() and maxDeposit() are inaccurate if Aave pool is frozen",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "EIP4626 states the following requirements for maxMint(): MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset. MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0. If an Aave pool is frozen, Aave documentation states it will not accept deposits. Therefore maxMint() and maxDeposit() should return zero in this case. The functions currently do not. Currently the senior vault is not compliant with the ERC4626 spec if the Aave pool is frozen.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. setGmxParams() doesn't update dependent variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "The value state.glpManager can be updated in setGmxParams() by the owner. The value state.gmxVault is set in initialize() by calling vault() in state.glpManager. When state.glpManager is updated, the value state.gmxVault is not updated, which may leave the gmx vault variable outdated.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Biased delta neutral position",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "The junior vault attempts to hold equal long and short positions to maintain a delta neutral position in the market. The reason this is done is to avoid impermanent loss, which is a common problem for liquidity providers. The junior vault holds a short position by borrowing WETH and WBTC from Aave (after depositing USDC to maintain a reasonable health factor). The junior vault holds an equal long position by holding GLP (technically fsGLP, the staked version of GLP) which consists of a basket of underlying assets mostly consistently of WETH, WBTC and stablecoins. There are two small ways in which the Rage Trade delta neutral strategy has bias in its holdings that could create unwanted exposure to certain assets. A consistent bias over the long run can impact yield returns to depositors because impermanent loss may cause losses in the long run. The GLP vault does not hold exactly 50% WETH & WBTC with the remaining 50% in stablecoins. It targets a holding of 1% LINK and 1% UNI, so in reality the targeted exposure is 35% WETH, 15% WBTC, 1% UNI, 1% LINK, and 50% stablecoins. The delta neutral strategy has no short position to cover the long exposure held in UNI or LINK. Although the percentage of UNI and LINK holdings is small, this exposure can result in non-zero impermanent loss over the long run. If there is an assumption that UNI and LINK prices are correlated to WETH and WBTC, then the value of the short positions should be increased to roughly 52% of the GLP value, rather than the currently targeted 50%. LINK is an asset that can be borrowed and shorted on Aave like WETH and WBTC currently are, an approach which would maintain a more precise neutral position. The second bias is that the process that rebalances the junior vault holdings consistently has more long exposure than short. This can be seen on the long timescale where the ratio is targeting 2 (the reason the target ratio is 2 and not 1 is because only 50% of the holdings in the GMX vault are WETH and WBTC) but the actual value is consistently above 2. Zooming in on the shorter timescale, observe the point in time when a rebalance happens in the middle of this plot. While the rebalance brings the ratio closer to 2, it could do better, and this inaccuracy may be due to an inaccuracy in the implementation's math.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Make functions external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "Make getVaultMarketValue() in the senior vault and the junior vault external, not public. The same can be done for getPriceX128() in the senior vault and the junior vault. getPriceX128() in the senior vault includes a comment that it is only used in the frontend.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Immutable variables are cheaper",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "pool can be immutable for gas savings.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Remove unused function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "getMaxVariableBorrowRate() is not used in any contracts in the Rage Trade repo and can be removed.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Remove duplicate length check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "The array length check in _executeFlashloan() is unnecessary because it is duplicated a few lines later when the Balancer vault flashloan() call happens.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Unnecessary addition operation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "usdcBorrowed is zero at the start of totalUsdcBorrowed(), so the line can be changed to: - if (address(leveragePool) != address(0)) usdcBorrowed += leveragePool.getUsdcBorrowed(); + if (address(leveragePool) != address(0)) usdcBorrowed = leveragePool.getUsdcBorrowed();",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. No way to remove approvals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "grantAllowances() in the junior vault and senior vault exists solely to set the allowances for the vault, even though these are set in the initializer(). It may also be useful to have a way to remove these allowances. For example, if the Aave pool address is updated or there is a security concern with an approved contract, it may be useful to remove the approval. But there is currently no ability to do this with the vaults. This ability may be useful to introduce because a paused vault will not prevent tokens from being withdrawn by an approved address when an infinite allowance is set.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Move Aave pool and oracle update to new function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "The second half of setHedgeParams() is unrelated to the first half and may not be necessary to use each time the other state variables are updated. Consider moving the second half of setHedgeParams() to a separate function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Unused dependencies imported",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "The WadRayMath import from Aave V3 is never used by DnGmxJuniorVault. The same applies to IRewardTracker.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Hypothetical revert condition breaks EIP4626 requirements",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "EIP4626 states totalAssets() has the requirement that it MUST NOT revert. But in the senior vault, the call flow totalAssets() -> totalUsdcBorrowed() -> dnGmxJuniorVault.getUsdcBorrowed() -> .toInt256() calls a SafeCast function that could revert if the uint256 value in getUsdcBorrowed() is greater than or equal to 2**255. It is unlikely that Rage Trade will hold this much value, which would equate to 2**249 dollars of value, but totalAssets() would revert in such a case.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "There are many instances of magic numbers with powers of ten. Consider replacing these magic numbers with a constant internal variable, which is already done in some cases like PRICE_PRECISION. Some examples are these magic numbers 1e12, 1e14, 1e16, and 1e30.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Unnecessary reimplementation of GMX functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "The junior vault's getPrice() and the junior vault manager's _getGlpPrice() functions are identical other than the different of the state function argument. Furthermore, these functions reimplement a function named getPrice() in GlpManager that returns the GLP price. In fact, the return value and decimals of the junior vault's getPrice() and getPrice() in GlpManager is identical, so arguably the function isn't needed at all and the GlpManager contract can be called directly when needed. The same applies to the first half of _getGlpPriceInUsdc() in the junior vault manager.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Library functions with unusual visibility",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "A library is slightly different than a contract in that the functions in a library are only accessible to the contract that imports the library. This means the junior vault manager library can remove any external functions that are declared external in the library but are not called by the junior vault (which is the only contract that imports the library). Such functions include getTokenReservesInGlp(), rebalanceBorrow(), getTokenPrice(), getGlpPrice(), getGlpPriceInUsdc(), getTokenPriceInUsdc(), getLiquidationThreshold(), flashloanAmounts(), getOptimalCappedBorrows(), getTokenReservesInGlp(), and isWithinAllowedDelta(). Another change that could be made with the library is combining external and internal functions if the external function only calls the internal function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Functions altering state variables missing events",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "Some functions that modify state variables do not emit events: updateFeeStrategyParams() unstakeAndVestEsGmx() stopVestAndStakeEsGmx() claimVestedGmx()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Dead link in ERC4626Upgradeable.sol comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "This link points to a repo that no longer exists.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Move excessUtilizationRate calculation in calculateFeeSplit() into if statement",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "description": "This line can be moved inside the if statement.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. The swap and stake mechanisms in OpenMevZapper leave funds in the contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "Both swapAndStakeLiquidity and swapETHAndStakeLiquidity take the input tokens or ETH sent by a user, divide it by 2, swap it into the B token, and stake these tokens as a pair. However, this approach leaves some of the B token in the contract due to the reserve asset ratio change before and after the swap.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Using normal functions for fee-on-transfer tokens causes value loss",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The NatSpec comment for removeLiquidityETHSupportingFeeOnTransferTokens() includes Identical to removeLiquidityETH, but succeeds for tokens that take a fee on transfer The only difference in these functions, and what is implied to cause the revert condition in removeLiquidityETH(), is the amount used in safeTransfer(). removeLiquidityETH() has an amount of amountToken, while removeLiquidityETHSupportingFeeOnTransferTokens() uses ERC20(token).balanceOf(address(this)) - balanceBefore. This does cause a revert in Uniswap's code because of the Uniswap assumption that the router holds no token balance, but OpenMevRouter can hold a token balance. The process of value loss is: Fee-on-transfer token is held by the router. This can happen either with an initial deposit by the Manifold team or from backrun arbitrage profits. The devs suggested the tokens that will be sent to the router will likely be tokens that Aave does not support flashloans for, which could include lesser known tokens with fee-on-transfer support. User wants to remove liquidity from WETH-ERC20 pair where the ERC20 has a non-zero fee-on-transfer. Instead of using removeLiquidityETHSupportingFeeOnTransferTokens(), the user calls removeLiquidityETH(). The code of removeLiquidityETHSupportingFeeOnTransferTokens() and removeLiquidityETH() is identical except for the amount in ERC20(token).safeTransfer(). The amountToken value used in removeLiquidityETH() is greater than the amount of fee-on-transfer tokens received from the removeLiquidity() call, so the amount transferred to the user will include some of the token balance that was held by the router before the user's remove liquidity interaction. Result: The router lost value in the form of the transfer-on-fee token",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Backrun arb not designed for fee-on-transfer tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "While Aave and Kashi do not currently allow flashloans on any fee-on-transfer tokens, this call of _arb() using internal router contract funds is problematic. The first and second swaps are performed with _asmSwap(), which have a safeTransfer() performed first to send the token to the pair address. It is assumed that the amountOut value calculated by OpenMevLibrary.getAmountOut() accurately stores the amount of tokens that the router contract receives from the swap process. Instead, to support fee-on-transfer tokens, a calculation of ERC20(token).balanceOf(address(this)) - balanceBefore as found in the router function removeLiquidityETHSupportingFeeOnTransferTokens() should be used. The _arb() function can even cause problems when neither the first nor last token is a fee-on-transfer token, but one of the intermediate swaps uses a fee-on-transfer token. Because the _backrunSwaps() function loops through the array of swaps, any of the backrun swaps that involve a fee-on-transfer token could be problematic.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Failed flashloan arbitrage reverts the original swap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "These lines include the revert for each flashloan [1, 2].",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Edge case suboptimal arb profit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The logic branch checks if contractAssetBalance >= optimalAmount, otherwise a flashloan is used.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. One failed arb can revert otherwise profitable arb",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The _backrunSwaps() function loops through the array of swaps. Imagine a scenario where _backrunSwaps() is called with a swaps array of length 4. Assume the 1st, 2nd, and 4th backrun swaps are profitable, but the 3rd backrun swap is not. Performing this series of four backrun swaps can still be net profitable even if one of the individual backrun swaps is not. The reason the 3rd backrun swap is not profitable may be because the flashloan fee costs more than the profit of this arb, which reverts here or here, or a similar revert can happen if the router contract funds are used for the arb and the amount received is less than expected. The result is the transaction reverts and OpenMevRouter will miss out on the arb profits if the swaps had been completed even if one individual backrun swap wasn't profitable.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Max approval granted to spender",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "ERC20(token).safeApprove(spender, type(uint256).max); in _approveTokenIfNeeded approves the spend to spent the entire balance.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. No check For Aave flashloan balance",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "L915 of OpenMevRouter",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Use _isNonZero() for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use _inc() instead of ++ and _dec() instead of --",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "There is one instance of an increment improvement. There are two instances of a double decrement that could be replaced with _dec(_decr()) or with unchecked { length - 2; }: First instance Second instance",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Bitshifting is cheaper than multiplication or division",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "There are four instance of divide by 2 operations that can use bitshifting for gas efficiency: First instance Second instance Third instance Fourth instance",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Unnecessary zero initialization",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Payable functions can save gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The following functions have the onlyOwner modifier and can be marked as payable First function Second function Third function",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Avoid && logic in require statements",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "One instance of require with && logic was found.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Declare constant internal when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The bento constant should be internal if possible.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Replace require with errors in OpenMevRouter",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "One instance in _addLiquidity (require(amountAOptimal",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Remove unused code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "First instance Second instance Third instance",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Use simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The _addLiquidity() function in OpenMenRouter.sol contains this code: if (amountBOptimal = amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT'); if (amountBOptimal = amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT'); if (amountAOptimal  amountBDesired) { uint256 amountAOptimal = OpenMevLibrary.quote(amountBDesired, reserveB, reserveA); require(amountAOptimal = amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT'); if (amountAOptimal = amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT'); if (amountBOptimal = 1. Two other instances of this are in OpenMevLibrary.sol (lines 270 and 331), but to show the example from _swapSupportingFeeOnTransferTokens(): swaps[i].isBackrunable = ((1000 * amountInput) / reserveInput) >= 1; Because >= 1 equates to > 0, and G1 shows how != 0 or _isNonZero() is better than > 0, the comparison can be simplified to swaps[i].isBackrunable = _isNonZero(((1000 * amountInput) / reserveInput));",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Combine reserve value checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "Most places where OpenMevLibrary.getAmountOut() in OpenMevZapper results in duplicated reserve checks.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Use msg global vars directly",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "msg.value is unnecessarily cached in: addLiquidityETH() swapETHForExactTokens() swapETHAndStakeLiquidity() msg.value can replace swaps[0].amountIn swapExactETHForTokens() here and here",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Remove duplicate internal function call",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "One example: First call Second call",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. deadline special case not aligned with permit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "EIP-2612 text ensure() function",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Replace pair.swap() with _asmSwap()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "Line 699 of OpenMEVRouter.sol",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Remove a sortTokens call",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The first sortTokens() call The second sortTokens() call happens in pairFor()",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Missing curly brace",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "This if statement is missing curly braces.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Reduce number of swaps",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "Consider the constant product diagram Point 1 shows the liquidity pool amounts before OpenMevRouter interaction, point 2 shows the amounts after the OpenMevRouter user swap, and point 3 shows the amounts after the first backrun of the arb process. These two steps can be combined to arrive from point 1 to point 3, skipping to need to swap to arrive at point 2. The math in OpenMevRouter.sol would need changing, but gas savings from removing one swap may be enough to reduce overall gas consumption.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Revert if zero flashloan profit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The revert logic for the kashi flashloan callback is currently: if (amountOver",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. OpenMevRouter should inherit from IFlashBorrower and IOpenMevRouter",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. The ETHERSCAN_API key is present in plaintext",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. SafeTransferLib does not match Solmate's main branch",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Incorrect comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The comment on line 1001 doesn't match the code in line 1002.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "There are many instances of the value 1000. Consider replacing this magic number with a constant internal variable named MINIMUM_LIQUIDITY like Uniswap does: First instance Second instance Third instance Fourth instance Fifth instance Other instances of magic numbers are found in calcCoeffs().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "First typo Second typo",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Hard coded Aave token list",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The hard coded list of tokens in OpenMevLibrary.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Inconsistency in WETH transfers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The one instance of a WETH transfer with require(IWETH(weth).transfer(pair, amount));. All other instances use IWETH(weth).deposit{ value: amount }(); First instance Second instance Third instance",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. safeApprove vulnerable to double withdraw",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "One relevant safeApprove() call was found. Permit is used in several functions in OpenMevRouter.sol: First function Second function Third function",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Same frontrunning weaknesses as Uniswap/SushiSwap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "Project documentation explaining these attack vectors still remain.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Kashi flashloanable tokens assumed same as aave",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "The logic to backrun a swap happens if either there is sufficient token balance in the router that no flashloan is needed, or the token can be flashloaned from Aave. There is no separate list of Kashi-supported flashloanable tokens. Only a list of Aave flashloanable tokens exists.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39.  (engn33r)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "description": "Incorrect comment for add512x512()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. decodeCtx() missing error checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. No function to unregister an agreement class",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. App registration front-running can set a different configword",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. appCallbackPop() missing modifier",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Unnecessary zero initialization",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Avoid && logic in require statements",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Use != 0 for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use short require strings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. External functions are cheaper than public functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Use prefix in loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Declare constant internal when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Use of memory for function arguments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Unnecessary variable computation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Shorted revert strings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Custom error",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Using >0 for unsigned integers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Unchecked counter incrementation in \"for\" loop",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Potential underflow condition",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Potential hash collision",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Logic inconsistency between callAgreementWithContext() and callAppActionWithContext()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Upgradable Superfluid.sol has hardcoded version",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. _callAppAction() logic varies from _callAgreement()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Use named cached variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. _replacePlaceholderCtx() logic could be simplified",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. _callCallback() logic can be simplified",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Broken link",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. FIXME or TODO comments remain in code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Incorrect external code reference",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Match callInfo masks and shifts to data size",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. isConfigWordClean doesn't check some unused bits",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Remove unnecessary casting to ISuperApp type",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Incorrect comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Variation in isTrustedForwarder() implementations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Implementation contracts not initialized",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "Superfluid, SuperfluidAgreement, SuperTokenFactory are deployed as UUPS proxy contracts. Anyone call their initialize() function as implementation contracts are not initialized.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Possible to register multiple apps with same registrationKey",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "Governance's owner can call setConfig() to allow an address a (hashed into key) to register a SuperApp with Superfluid.sol (host). The value parameter is the timestamp until which the address can register the app. a can initiate a transaction to register multiple apps through registerAppWithKey() as long as block.timestamp",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Valid context is not checked before modifying it",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "For reference, appCallbackPush() has asserts a valid context through assertValidCtx(ctx). There is no such verification for appCallbackPop().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Typo",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "agreeement (Superfluid.sol#L1053 and Superfluid.sol#L1063) might be better spelled as agreement.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Ambiguous endian of bitmap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Add more comments and documentation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "description": "There is NatSpec on the interface ISuperfluid.sol but still lacking on documentation and inline comments.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    }
]